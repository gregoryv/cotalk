<!DOCTYPE html>

<html>
<head>
<title>Go concurrency</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>html, body {
margin: 0 0;
padding: 0 0;
}
.slide {
padding: 10px 20%;
text-align: center;
height: calc( 100vh - 50px);
}
p, pre {
text-align: left;
}
.slide ul {
text-align: left;
}
.slide nav {
text-align: center;
}
.slide nav ul {
list-style-type: none;
margin: 0 0;
padding: 0 0;
text-align: center;
}
nav ul li {
margin: 0 4px;
cursor: pointer;
display: inline;
}
nav ul li.current {
text-decoration: underline;
}
a:link, a:visited {
color: #007d9c;
text-decoration: none;
}
a:hover {
text-decoration: underline;
}
.header {
width: 100%;
border-bottom: 1px solid #727272;
text-align: right;
margin-top: -2em;
margin-bottom: 1em;
}
h1, h2, h3 {
text-align: center;
}
.srcfile {
margin-top: 1.6em;
margin-bottom: 1.6em;
background-image: url("printout-whole.png");
background-repeat: repeat-y;
padding-left: 36px;
background-color: #fafafa;
tab-size: 4;
-moz-tab-size: 4;
}
.filename {
float: left;
margin-right: 1.6em;
margin-top: -1.6em;
}
.srcfile code {
padding: .6em 0 .6em 0;
background-image: url("printout-whole.png");
background-repeat: repeat-y;
background-position: right top;
display: block;
text-align: left;
}
nav {
float: left;
clear: both;
width: 100%;
display: block;
margin-top: 1em;
text-align: center;
}
nav a:link, nav a:visited {
color: #727272;
padding: 0 5px;
margin: 0 2px;
text-decoration: none;
}
nav a.current, nav a:hover {
color: black;
border-bottom: 1px solid black;
}
li.h3 {
margin-left: 2em;
}
.shell {
padding: 1em;
border-radius: 10px;
}
.dark {
background-color: #2e2e34;
color: aliceblue;
}
.light {
background-color: #ffffff;
color: #3b2616;
}
img.center {
display: block;
margin-left: auto;
margin-right: auto;
}
img.left {
float: left;
margin-right: 2em;
}
.group {
float: left;
text-align: left;
margin-right: 3em;
}
.keyword {
color: darkviolet;
}
.type {
color: dodgerblue;
}
.comment, .comment>span {
color: darkgreen;
}
</style>
</head>
<body>
<div class="slide" id="1"><a href="#2"><img src="cotalk.png"/></a><span>2023 by Gregory Vinčić</span></div>
<div class="slide" id="2"><h1>Content</h1>
<ul class="group">
<li>background and history</li>
<li>goroutines</li>
<li>channels</li>
<li>package context</li>
<li>package sync </li>
</ul>
<ul class="group">
<li>go test bench</li>
<li>problem definition</li>
<li>sequential solution</li>
</ul>
<ul class="group">
<li>concurrent solution</li>
<li>fixing bugs</li>
</ul>
<ul class="group">
<li>using channels</li>
<li>synchronizing</li>
</ul>
<br clear="all"/><p>Follow along by cloning the examples with </p>
<pre class="shell dark">$ git clone git@github.com:preferit/cotalk.git
$ cd cotalk</pre><br clear="all"/><nav><ul>
<li><a href="#1">1</a></li>
<li class="current"><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li> | </li>
<li><a href="#8">8</a></li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li> | </li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li> | </li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
</ul>
</nav>
</div>
<div class="slide" id="3"><h2>Background and history</h2>
<img class="left" src="th_small.jpg"/><br/><p>Sir Charles Antony Richard Hoare (<a href="https://en.wikipedia.org/wiki/Tony_Hoare">Tony Hoare</a>). Born 1934 in Sri Lanka, studied at Oxford and in
			Moscow. His research spanned program correctness, sorting
			and programming languages. His work is freely accessible
			online and the Go developers uses his concept of <em>channels</em>
			in the language.</p>
<ul>
<li><a href="https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf">Communicating Sequential Processes (CSP), paper 1978</a></li>
<li><a href="http://www.usingcsp.com/cspbook.pdf">CSP, book 1985</a></li>
</ul>
<nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li class="current"><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li> | </li>
<li><a href="#8">8</a></li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li> | </li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li> | </li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
</ul>
</nav>
</div>
<div class="slide" id="4"><h2>Goroutines</h2>
<a target="_blank" href="https://go.dev/tour/concurrency/1"><img class="center" src="gotour_concurrency_1.png"/></a><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li class="current"><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li> | </li>
<li><a href="#8">8</a></li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li> | </li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li> | </li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
</ul>
</nav>
</div>
<div class="slide" id="5"><h2>channels</h2>
<a target="_blank" href="https://go.dev/tour/concurrency/2"><img class="center" src="gotour_concurrency_2.png"/></a><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li class="current"><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li> | </li>
<li><a href="#8">8</a></li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li> | </li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li> | </li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
</ul>
</nav>
</div>
<div class="slide" id="6"><h2>package sync</h2>
<div class="srcfile"><pre><code><span class="keyword">type</span> Cond <span class="keyword">struct</span>{ ... }
    <span class="keyword">func</span> NewCond(l Locker) *Cond
<span class="keyword">type</span> Locker <span class="keyword">interface</span>{ ... }
<span class="keyword">type</span> Map <span class="keyword">struct</span>{ ... }
<span class="keyword">type</span> Mutex <span class="keyword">struct</span>{ ... }
<span class="keyword">type</span> Once <span class="keyword">struct</span>{ ... }
<span class="keyword">type</span> Pool <span class="keyword">struct</span>{ ... }
<span class="keyword">type</span> RWMutex <span class="keyword">struct</span>{ ... }
<span class="keyword">type</span> WaitGroup <span class="keyword">struct</span>{ ... }
</code></pre></div>
<a target="_blank" href="https://pkg.go.dev/sync">pkg.go.dev/sync</a><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li class="current"><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li> | </li>
<li><a href="#8">8</a></li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li> | </li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li> | </li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
</ul>
</nav>
</div>
<div class="slide" id="7"><h2>package context</h2>
<pre>
Programs that use Contexts should follow these rules

Do not store Contexts inside a <span class="keyword">struct</span> <span class="keyword">type</span>; instead, pass a Context
explicitly to each function that needs it. The Context should be the
first parameter, typically named ctx:

<span class="keyword">func</span> DoSomething(ctx context.Context, arg Arg) error {
	<span class="comment">// ... use ctx ...</span>
}

Do not pass a nil Context, even if a function permits it. Pass
context.TODO if you are unsure about which Context to use.

Use context Values only for request-scoped data that transits
processes and APIs, not for passing optional parameters to functions.
		</pre><div class="srcfile"><pre><code>var Canceled = errors.New("context canceled")
var DeadlineExceeded error = deadlineExceededError{}
<span class="keyword">func</span> WithCancel(parent Context) (ctx Context, cancel CancelFunc)
<span class="keyword">func</span> WithDeadline(parent Context, d <span class="type">time.Time</span>) (Context, CancelFunc)
<span class="keyword">func</span> WithTimeout(parent Context, timeout <span class="type">time.Duration</span>) (Context, CancelFunc)
<span class="keyword">type</span> CancelFunc <span class="keyword">func</span>()
<span class="keyword">type</span> Context <span class="keyword">interface</span>{ ... }
    <span class="keyword">func</span> Background() Context
    <span class="keyword">func</span> TODO() Context
    <span class="keyword">func</span> WithValue(parent Context, key, val any) Context
</code></pre></div>
<a target="_blank" href="https://pkg.go.dev/context">pkg.go.dev/context</a><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li class="current"><a href="#7">7</a></li>
<li> | </li>
<li><a href="#8">8</a></li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li> | </li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li> | </li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
</ul>
</nav>
</div>
<div class="slide" id="8"><h2>go test -bench</h2>
<div class="srcfile"><pre><code><span class="keyword">package</span> cotalk

<span class="keyword">import</span> (
    "fmt"
    "testing"
    "time"
)

<span class="keyword">func</span> BenchmarkX(b *<span class="type">testing.B</span>) {
    fmt.Println("N is", <span class="type">b.N</span>)
    <span class="keyword">for</span> i := 0; i < b.N; i++ {
        X()
    }
}

<span class="keyword">func</span> X() {
    time.Sleep(<span class="type">time.Millisecond</span>)
}
</code></pre></div>
<pre class="shell dark">$ go test -bench=BenchmarkX -v .<br/>goos: linux
goarch: amd64
pkg: github.com/preferit/cotalk
cpu: Intel(R) Xeon(R) E-2288G CPU @ 3.70GHz
BenchmarkX
N is 1
N is 100
N is 1100
BenchmarkX-16    	    1100	   1095229 ns/op
<span style="color:green;">PASS</span>
ok  	github.com/preferit/cotalk	1.320s
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li> | </li>
<li class="current"><a href="#8">8</a></li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li> | </li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li> | </li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
</ul>
</nav>
</div>
<div class="slide" id="9"><h2>Problem</h2>
<p>A set of letters <code>0 1 2 3 4 5 6 7 8 9 a b c d e f</code> are available on a server; the problem is to GET them
			and assemble them in the correct order. Each letter is
			found on /L, ie. GET /3 would return '3'.</p>
<p>To simplify the examples we define the Algorithm that does the work as<pre><code><span class="keyword">type</span> Algorithm <span class="keyword">func</span>(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>)</code></pre></p>
<nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li> | </li>
<li><a href="#8">8</a></li>
<li class="current"><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li> | </li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li> | </li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
</ul>
</nav>
</div>
<div class="slide" id="10"><h2>Verification</h2>
<p>Each algorithm in these examples is tested like this</p>
<div class="srcfile"><pre><code><span class="keyword">func</span> BenchmarkAlg1(b *<span class="type">testing.B</span>) {
    srv, problem := Setup()
    <span class="keyword">defer</span> srv.Close()
    <span class="keyword">for</span> i := 0; i < b.N; i++ {
        <span class="keyword">if</span> err := problem.Solve(Alg1); err != nil {
            b.Fatal(err)
        }
    }
}</code></pre></div>
<p>The problem and it's verification method Solve is found
in <a href="https://github.com/preferit/cotalk/blob/main/problem.go">problem.go</a></p>
<nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li> | </li>
<li><a href="#8">8</a></li>
<li><a href="#9">9</a></li>
<li class="current"><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li> | </li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li> | </li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
</ul>
</nav>
</div>
<div class="slide" id="11"><h2>Sequential</h2>
<p>Simple implementation though very low performance</p>
<div class="srcfile"><pre><code><span class="comment">// Alg1 solves the work sequentially</span>
<span class="keyword">func</span> Alg1(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {
    <span class="keyword">for</span> _, r := <span class="keyword">range</span> work {
        resp, _ := http.DefaultClient.Do(r)
        result = append(result, resp)
    }
    <span class="keyword">return</span>
}
</code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg1 .<br/>goos: linux
goarch: amd64
pkg: github.com/preferit/cotalk
cpu: Intel(R) Xeon(R) E-2288G CPU @ 3.70GHz
BenchmarkAlg1-16    	       6	 175723081 ns/op	  276461 B/op	    1978 allocs/op
<span style="color:green;">PASS</span>
ok  	github.com/preferit/cotalk	1.238s
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li> | </li>
<li><a href="#8">8</a></li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li class="current"><a href="#11">11</a></li>
<li> | </li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li> | </li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
</ul>
</nav>
</div>
<div class="slide" id="12"><h2>Concurrent</h2>
<p>This algorithm uses the sync.WaitGroup to wait for all requests to complete; however it has several bugs.</p>
<div class="srcfile"><pre><code><span class="comment">// Alg2 uses sync.WaitGroup to wait <span class="keyword">for</span> all responses</span>
<span class="keyword">func</span> Alg2(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {
    <span class="keyword">var</span> wg <span class="type">sync.WaitGroup</span>
    <span class="keyword">for</span> _, r := <span class="keyword">range</span> work {
        wg.Add(1)
        <span class="keyword">go</span> <span class="keyword">func</span>() {
            resp, _ := http.DefaultClient.Do(r)
            result = append(result, resp)
            wg.Done()
        }()
    }
    wg.Wait()
    <span class="keyword">return</span>
}
</code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg2 .<br/><span style="color:red;">--- FAIL:</span> BenchmarkAlg2
    alg_test.go:22: 
        exp: 0 1 2 3 4 5 6 7 8 9 a b c d e f
        got: f f f f f f f f f f f f f f f f
<span style="color:red;">FAIL</span>
exit status 1
<span style="color:red;">FAIL</span>	github.com/preferit/cotalk	0.013s
<span style="color:red;">FAIL</span>
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li> | </li>
<li><a href="#8">8</a></li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li> | </li>
<li class="current"><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li> | </li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
</ul>
</nav>
</div>
<div class="slide" id="13"><h2>Concurrent</h2>
<p>Bug 1; you cannot assume go routines start immediately.</p>
<div class="srcfile"><pre><code><span class="comment">// Alg3 fixes reference problem inside loop</span>
<span class="keyword">func</span> Alg3(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {
    <span class="keyword">var</span> wg <span class="type">sync.WaitGroup</span>
    <span class="keyword">for</span> _, r := <span class="keyword">range</span> work {
        wg.Add(1)
        <span class="keyword">go</span> <span class="keyword">func</span>(lr *<span class="type">http.Request</span>) {
            <span class="comment">// use local argument</span>
            resp, _ := http.DefaultClient.Do(lr)
            result = append(result, resp)
            wg.Done()
        }(r) <span class="comment">// make a copy of pointer with argument</span>
    }
    wg.Wait()
    <span class="keyword">return</span>
}
</code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg3 .<br/><span style="color:red;">--- FAIL:</span> BenchmarkAlg3
    alg_test.go:32: 
        exp: 0 1 2 3 4 5 6 7 8 9 a b c d e f
        got: 1 0 5 8 6 2 e 7 d f b 4 c 9 3
<span style="color:red;">FAIL</span>
exit status 1
<span style="color:red;">FAIL</span>	github.com/preferit/cotalk	0.014s
<span style="color:red;">FAIL</span>
</pre><p>You might get a different result; but why does it fail?</p>
<nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li> | </li>
<li><a href="#8">8</a></li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li> | </li>
<li><a href="#12">12</a></li>
<li class="current"><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li> | </li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
</ul>
</nav>
</div>
<div class="slide" id="14"><h2>Concurrent</h2>
<p>Bug 2; Unprotected write to slice</p>
<div class="srcfile"><pre><code><span class="comment">// Alg4 synchronizes writes accross <span class="keyword">go</span> routines</span>
<span class="keyword">func</span> Alg4(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {
    <span class="keyword">var</span> wg <span class="type">sync.WaitGroup</span>
    <span class="keyword">var</span> m <span class="type">sync.Mutex</span>
    <span class="keyword">for</span> _, r := <span class="keyword">range</span> work {
        wg.Add(1)
        <span class="keyword">go</span> <span class="keyword">func</span>(lr *<span class="type">http.Request</span>) {
            resp, _ := http.DefaultClient.Do(lr)
            <span class="comment">// protect result</span>
            m.Lock()
            result = append(result, resp)
            m.Unlock()
            wg.Done()
        }(r)
    }
    wg.Wait()
    <span class="keyword">return</span>
}
</code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg4 .<br/><span style="color:red;">--- FAIL:</span> BenchmarkAlg4
    alg_test.go:42: 
        exp: 0 1 2 3 4 5 6 7 8 9 a b c d e f
        got: d 1 c 5 4 3 8 7 e 2 a 9 f 6 b 0
<span style="color:red;">FAIL</span>
exit status 1
<span style="color:red;">FAIL</span>	github.com/preferit/cotalk	0.014s
<span style="color:red;">FAIL</span>
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li> | </li>
<li><a href="#8">8</a></li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li> | </li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li class="current"><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li> | </li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
</ul>
</nav>
</div>
<div class="slide" id="15"><h2>Concurrent</h2>
<p>Bug 3; Fix order</p>
<div class="srcfile"><pre><code><span class="comment">// Alg5 fix order</span>
<span class="keyword">func</span> Alg5(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {
    <span class="keyword">var</span> wg <span class="type">sync.WaitGroup</span>
    <span class="keyword">var</span> m <span class="type">sync.Mutex</span>
    result = make([]*http.Response, len(work))
    <span class="keyword">for</span> i, r := <span class="keyword">range</span> work {
        wg.Add(1)
        <span class="keyword">go</span> <span class="keyword">func</span>(i int, lr *<span class="type">http.Request</span>) {
            resp, _ := http.DefaultClient.Do(lr)
            <span class="comment">// protect result</span>
            m.Lock()
            result[i] = resp
            m.Unlock()
            wg.Done()
        }(i, r)
    }
    wg.Wait()
    <span class="keyword">return</span>
}
</code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg5 .<br/>goos: linux
goarch: amd64
pkg: github.com/preferit/cotalk
cpu: Intel(R) Xeon(R) E-2288G CPU @ 3.70GHz
BenchmarkAlg5-16    	     100	  13281838 ns/op	  289424 B/op	    2018 allocs/op
<span style="color:green;">PASS</span>
ok  	github.com/preferit/cotalk	1.344s
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li> | </li>
<li><a href="#8">8</a></li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li> | </li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li class="current"><a href="#15">15</a></li>
<li> | </li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
</ul>
</nav>
</div>
<div class="slide" id="16"><h2>Using channel</h2>
<div class="srcfile"><pre><code><span class="comment">// Alg6 uses channel to synchronize responses</span>
<span class="keyword">func</span> Alg6(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {
    c := make(chan *<span class="type">http.Response</span>)
    <span class="keyword">for</span> _, r := <span class="keyword">range</span> work {
        <span class="keyword">go</span> <span class="keyword">func</span>(lr *<span class="type">http.Request</span>) {
            resp, _ := http.DefaultClient.Do(lr)
            c <- resp <span class="comment">// write to channel</span>
        }(r)
    }
    <span class="keyword">for</span> <span class="keyword">range</span> work {
        resp := <-c <span class="comment">// read from channel</span>
        result = append(result, resp)
    }
    <span class="keyword">return</span>
}
</code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg6 .<br/><span style="color:red;">--- FAIL:</span> BenchmarkAlg6
    alg_test.go:62: 
        exp: 0 1 2 3 4 5 6 7 8 9 a b c d e f
        got: f c b 9 d a 0 3 4 2 5 7 e 1 6 8
<span style="color:red;">FAIL</span>
exit status 1
<span style="color:red;">FAIL</span>	github.com/preferit/cotalk	0.014s
<span style="color:red;">FAIL</span>
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li> | </li>
<li><a href="#8">8</a></li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li> | </li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li> | </li>
<li class="current"><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
</ul>
</nav>
</div>
<div class="slide" id="17"><h2>Correct order using channel</h2>
<div class="srcfile"><pre><code><span class="comment">// Alg7 uses channel to synchronize responses with ordered result</span>
<span class="keyword">func</span> Alg7(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {
    <span class="keyword">type</span> m <span class="keyword">struct</span> {
        index int
        *<span class="type">http.Response</span>
    }
    c := make(chan m)
    result = make([]*http.Response, len(work))
    <span class="keyword">for</span> i, r := <span class="keyword">range</span> work {
        <span class="keyword">go</span> <span class="keyword">func</span>(i int, lr *<span class="type">http.Request</span>) {
            resp, _ := http.DefaultClient.Do(lr)
            c <- m{i, resp} <span class="comment">// write to channel</span>
        }(i, r)
    }
    <span class="keyword">for</span> <span class="keyword">range</span> work {
        v := <-c <span class="comment">// read from channel</span>
        result[v.index] = <span class="type">v.Response</span>
    }
    <span class="keyword">return</span>
}
</code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg7 .<br/>goos: linux
goarch: amd64
pkg: github.com/preferit/cotalk
cpu: Intel(R) Xeon(R) E-2288G CPU @ 3.70GHz
BenchmarkAlg7-16    	     100	  13411328 ns/op	  293160 B/op	    2025 allocs/op
<span style="color:green;">PASS</span>
ok  	github.com/preferit/cotalk	1.357s
</pre><p>There is still a bug in this code, do you see it?</p>
<nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li> | </li>
<li><a href="#8">8</a></li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li> | </li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li> | </li>
<li><a href="#16">16</a></li>
<li class="current"><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
</ul>
</nav>
</div>
<div class="slide" id="18"><h2>Clean up resources</h2>
<div class="srcfile"><pre><code><span class="comment">// Alg8 uses channel to synchronize responses with ordered result</span>
<span class="keyword">func</span> Alg8(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {
    <span class="keyword">type</span> m <span class="keyword">struct</span> {
        index int
        *<span class="type">http.Response</span>
    }
    c := make(chan m)
    <span class="keyword">defer</span> close(c) <span class="comment">// make sure you clean up when done</span>
    result = make([]*http.Response, len(work))
    <span class="keyword">for</span> i, r := <span class="keyword">range</span> work {
        <span class="keyword">go</span> <span class="keyword">func</span>(i int, lr *<span class="type">http.Request</span>) {
            resp, _ := http.DefaultClient.Do(lr)
            c <- m{i, resp} <span class="comment">// write to channel</span>
        }(i, r)
    }
    <span class="keyword">for</span> <span class="keyword">range</span> work {
        v := <-c <span class="comment">// read from channel</span>
        result[v.index] = <span class="type">v.Response</span>
    }
    <span class="keyword">return</span>
}
</code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg8 .<br/>goos: linux
goarch: amd64
pkg: github.com/preferit/cotalk
cpu: Intel(R) Xeon(R) E-2288G CPU @ 3.70GHz
BenchmarkAlg8-16    	      99	  13400211 ns/op	  292396 B/op	    2022 allocs/op
<span style="color:green;">PASS</span>
ok  	github.com/preferit/cotalk	1.356s
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li> | </li>
<li><a href="#8">8</a></li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li> | </li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li> | </li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
<li class="current"><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
</ul>
</nav>
</div>
<div class="slide" id="19"><h2>Interrupt</h2>
<div class="srcfile"><pre><code><span class="comment">// Alg9 returns when all work is done or context is cancelled</span>
<span class="keyword">func</span> Alg9(ctx context.Context, work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {
    <span class="keyword">type</span> m <span class="keyword">struct</span> {
        index int
        *<span class="type">http.Response</span>
    }
    c := make(chan m)
    complete := make(chan <span class="keyword">struct</span>{})
    <span class="keyword">defer</span> close(c) <span class="comment">// make sure you clean up when done</span>
    result = make([]*http.Response, len(work))
    <span class="keyword">go</span> <span class="keyword">func</span>() {
        <span class="keyword">defer</span> close(complete)
        <span class="keyword">for</span> i, r := <span class="keyword">range</span> work {
            <span class="keyword">go</span> <span class="keyword">func</span>(i int, lr *<span class="type">http.Request</span>) {
                resp, _ := http.DefaultClient.Do(lr)
                c <- m{i, resp} <span class="comment">// write to channel</span>
            }(i, r)
        }
        <span class="keyword">for</span> <span class="keyword">range</span> work {
            v := <-c <span class="comment">// read from channel</span>
            result[v.index] = <span class="type">v.Response</span>
        }
    }()
    <span class="keyword">select</span> {
    <span class="keyword">case</span> <-ctx.Done():
        <span class="comment">// interrupted</span>
    <span class="keyword">case</span> <-complete:
    }
    <span class="keyword">return</span>
}
</code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg9 .<br/>goos: linux
goarch: amd64
pkg: github.com/preferit/cotalk
cpu: Intel(R) Xeon(R) E-2288G CPU @ 3.70GHz
BenchmarkAlg9-16    	panic: <span style="color:red;">send on closed channel</span>

goroutine 499 [running]:
github.com/preferit/cotalk.Alg9.func1.1(0x3, 0xc00040a780?)
	/home/gregory/src/github.com/preferit/cotalk/alg.go:162 +0x55
created by github.com/preferit/cotalk.Alg9.func1
	/home/gregory/src/github.com/preferit/cotalk/alg.go:160 +0x8e
exit status 2
<span style="color:red;">FAIL</span>	github.com/preferit/cotalk	0.054s
<span style="color:red;">FAIL</span>
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li> | </li>
<li><a href="#8">8</a></li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li> | </li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li> | </li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li class="current"><a href="#19">19</a></li>
</ul>
</nav>
</div>
</body>
</html>
