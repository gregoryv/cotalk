<!DOCTYPE html>

<html>
<head>
<meta charset="utf-8"/>
<title>Go Concurrency</title>
<style>html, body {
margin: 0 0;
padding: 0 0;
background-color: #fff;
}
.page {
height: 100vh;
position: relative;
margin-bottom: 1vh;
}
.page .view {
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 2vh;
}
.page .footer {
position: absolute;
bottom: 0;
left: 0;
right: 0;
text-align: center;
height: 2vh;
}
.page .footer .next {
position: absolute;
right: 1em;
cursor: pointer;
}
.page .footer .prev {
position: absolute;
left: 1em;
cursor: pointer;
}
.page .view {
font-size: 2vw;
margin: 0 0;
padding: 0 0;
}
.page .view .header {
text-align: center;
height: 14vh;
overflow: hidden;
}
.header {
background-image: url('img/blue_gopher.svg');
background-repeat: no-repeat;
background-position: 80px 10px;
}
.header h1, .header h2, .header .group {
font-weight: bold;
margin-top: 3vh;
font-size: 5vh;
margin-bottom: 0vh;
}
.header h3 {
margin-top: 0vh;
font-size: 3vh;
}
.page .view .slide {
margin: auto;
padding: 0.8vw 1.6vw 0.8vw 1.6vw;
height: 79vh;
overflow: hidden;
}
.page .view .cover {
display: flex;
justify-content: center;
align-items: center;
height: 82vh;
text-align: center;
}
.toc {
position: absolute;
left: 27vw;
width: 55vw;
padding-top: 1em;
}
.toc ul {
margin-top: 0;
}
a {
text-decoration: none;
color: #000;
}
a:hover {
text-decoration: underline;
}
.h3 {
margin-left: 5vw;
list-style-type: circle;
}
.trail {
position: absolute;
height: 6px;
width: 6px;
border-radius: 3px;
background: red;
}
.outline {
border: 1px solid black;
}
.center {
text-align: center;
}
.double {
}
.column.left {
position: absolute;
left: 4vw;
width: 40vw;
}
.column.right {
position: absolute;
left: 50vw;
width: 40vw;
}
.srcfile {
margin-top: 1.6em;
margin-bottom: 1.6em;
background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAlCAMAAAB1cTk3AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAjVBMVEX9/fz4+Pb19fP8/Pz39/Xp6ejr6+rs7Ov29vTt7evo6Oj6+vr7+/vv7+/u7u3v7+37+/ru7uzw8PD////29vbx8fD6+vjq6unz8/L5+ff39/f9/f3y8vHo6Ofx8fHw8O/z8/P6+vn4+Pj09PL+/v729vXp6efy8vDv7+709PTz8/H7+/n8/Pv5+fju7u5JBELWAAAAAWJLR0QB/wIt3gAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB+cFHw8tIWAQRK8AAAC5SURBVCjPpZDbEoIgEIaXQLPUNNFOWJrRyQ7v/3gJAs2EFzTuBex+8+/uDwDIiglgGyItJJ4/9YM+DxSczcMowvFCFgmk4lpmVEZeiGolYbCmKjZiQgp4i5C305CVPezOPTVxMLD6wrorj79K0U6kpaQxM0/GPIm5gmdilKise9ZI4UW96HoLGcN3ybpF+hPaomxV+oCn/Ukv4DZMgdqQOkMMb0clG4L5uO3/wAGf3Ll9UJk5Lxpr/gOpxRF8cA+lxgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMy0wNS0zMVQxMzo0NTozMyswMjowMJXHbJYAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjMtMDUtMzFUMTM6NDU6MzMrMDI6MDDkmtQqAAAAAElFTkSuQmCC);
background-repeat: repeat-y;
background-size: 20px;
padding-left: 16px;
background-color: #fafafa;
tab-size: 4;
-moz-tab-size: 4;
font-size: 2vh;
}
.srcfile code {
margin-left: 0px;
padding-right: 20px;
padding: 0 0 0 0;
background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAlCAMAAAB1cTk3AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAjVBMVEX9/fz4+Pb19fP8/Pz39/Xp6ejr6+rs7Ov29vTt7evo6Oj6+vr7+/vv7+/u7u3v7+37+/ru7uzw8PD////29vbx8fD6+vjq6unz8/L5+ff39/f9/f3y8vHo6Ofx8fHw8O/z8/P6+vn4+Pj09PL+/v729vXp6efy8vDv7+709PTz8/H7+/n8/Pv5+fju7u5JBELWAAAAAWJLR0QB/wIt3gAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB+cFHw8tIWAQRK8AAAC5SURBVCjPpZDbEoIgEIaXQLPUNNFOWJrRyQ7v/3gJAs2EFzTuBex+8+/uDwDIiglgGyItJJ4/9YM+DxSczcMowvFCFgmk4lpmVEZeiGolYbCmKjZiQgp4i5C305CVPezOPTVxMLD6wrorj79K0U6kpaQxM0/GPIm5gmdilKise9ZI4UW96HoLGcN3ybpF+hPaomxV+oCn/Ukv4DZMgdqQOkMMb0clG4L5uO3/wAGf3Ll9UJk5Lxpr/gOpxRF8cA+lxgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMy0wNS0zMVQxMzo0NTozMyswMjowMJXHbJYAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjMtMDUtMzFUMTM6NDU6MzMrMDI6MDDkmtQqAAAAAElFTkSuQmCC);
background-repeat: repeat-y;
background-position: right top;
background-size: 20px;
display: block;
text-align: left;
font-family: Inconsolata, monospace;
overflow: hidden;
}
.srcfile ol {
margin-left: 0vw;
padding-left: 3vw;
}
.srcfile ol li {
white-space: pre;
}
.srcfile ol li::marker {
color: RGB(0,0,0,0.2);
}
.srcfile ol li:hover {
background-color: RGB(180,238,180,0.3);
}
.srcfile code i {
font-style: normal;
color: #a2a2a2;
}
.keyword {
color: darkviolet;
}
.type {
color: dodgerblue;
}
.comment, .comment>span {
color: darkgreen;
}
.header {
background-color: #f6f5f4;
border-bottom: 1px inset #000;
}
.page .footer {
bottom: 1vh;
}
.right>*, .right .shell {
margin-right: 1em;
}
.toc {
position: absolute;
font-size: 0.9em;
left: 13vw;
width: 73vw;
padding-top: 1em;
}
.shell {
padding: 1em;
border-radius: 10px;
overflow: wrap;
}
.dark {
background-color: #2e2e34;
color: aliceblue;
}
nav {
column-count: 2;
font-size: 0.8em;
}
.srcfile ol {
padding-right: 40px;
}
.shell {
font-size: 1.5vw;
}
p>a {
text-decoration: underline;
}
quote {
display: inline-block;
font-style: italic;
padding-left: 2vw;
padding-right: 2vw;
font-size: 1.5vw;
}
quote>a {
font-size: 1vw;
float: right;
}
quote.small {
font-size: 1vw;
}
.srcfile {
font-size: 1.3vw;
}
.filename {
display: block;
font-size: 0.8vw;
text-align: right;
margin-top: 2em;
margin-bottom: -2em;
}
.icons {
column-count: 3;
list-style-type: none;
}
.small * {
font-size: 0.9vw;
}
.small .filename {
margin-bottom: -1.5em;
}
.stop>img {
text-align: center;
float:left;
margin-right: 20px;
}
.stop>p {
padding-top: 50px;
color: red;
}
.smallerFont srcfile {
font-size: 0.8em;
}
</style>
</head>
<body>
<div class="page" id="1"><div class="view"><div class="cover"><table>
<tr><td><h1>Go Concurrency</h1>
</td></tr>
<tr><td><img src="cotalk.png"/></td></tr>
<tr><td><br/>Gregory Vinčić<br/><span style="font-size: 0.7em">2025</span></td></tr>
</table>
</div>
</div>
<div class="footer"><em class="prev">&nbsp;</em><em class="next">&nbsp;</em>1/25</div>
</div>
<div class="page" id="2"><div class="view"><div class="header"><h2>Go Concurrency</h2>
</div>
<div class="slide"><div class="toc"><nav><ul>
<li class="h2"><a href="#3">Concurrency constructs</a></li>
<li class="h3"><a href="#4">Go routines</a></li>
<li class="h3"><a href="#5">Channels</a></li>
<li class="h3"><a href="#6">Package sync</a></li>
<li class="h3"><a href="#7">Package context</a></li>
<li class="h2"><a href="#8">go test -bench</a></li>
<li class="h2"><a href="#9">Problem</a></li>
<li class="h3"><a href="#10">The letter challenge</a></li>
<li class="h3"><a href="#11">Verification</a></li>
<li class="h3"><a href="#12">Sequential</a></li>
<li class="h2"><a href="#13">Concurrent using sync.WaitGroup</a></li>
<li class="h2"><a href="#14">Concurrent using sync.WaitGroup Go 1.23</a></li>
<li class="h2"><a href="#15">Arguments are evaluated at calltime</a></li>
<li class="h2"><a href="#16">Protect concurrent writes with sync.Mutex</a></li>
<li class="h2"><a href="#17">Sort results</a></li>
<li class="h2"><a href="#18">Improved performance paid with complexity</a></li>
<li class="h2"><a href="#19">Using channel</a></li>
<li class="h3"><a href="#20">Correct order using channel</a></li>
<li class="h2"><a href="#21">Clean up resources</a></li>
<li class="h2"><a href="#22">Interrupt</a></li>
<li class="h2"><a href="#23">Respect context cancellation</a></li>
<li class="h2"><a href="#24">Compare all</a></li>
<li class="h2"><a href="#25">Summary</a></li>
</ul>
</nav>
</div>
</div>
</div>
<div class="footer"><em class="prev">&nbsp;</em><em class="next" onclick="nextPage()">Concurrency constructs &raquo;</em>2/25</div>
</div>
<div class="page" id="3"><div class="view"><div class="header"><h2>Concurrency constructs</h2>
</div>
<div class="slide"><div style="position: absolute; left: 10vw; width: 80vw"><img src="th_small.jpg" style="float: left; margin: 1em 1em"/><p>Sir Charles Antony Richard Hoare (<a href="https://en.wikipedia.org/wiki/Tony_Hoare">Tony Hoare</a>). Born 1934 in Sri Lanka, studied at Oxford and in
			Moscow. His research spanned program correctness, sorting
			and programming languages. His work is freely accessible
			online and the channel concept is described in the book <a href="http://www.usingcsp.com/cspbook.pdf">Communicating Sequential Processes (CSP) from 1985</a></p>
</div>
</div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; Go Concurrency</em><em class="next" onclick="nextPage()">Concurrency constructs Go routines &raquo;</em>3/25</div>
</div>
<div class="page" id="4"><div class="view"><div class="header"><div class="group">Concurrency constructs</div>
<h3>Go routines</h3>
</div>
<div class="slide"><div style="position: absolute; left: 25vw; width: 50vw"><a target="_blank" href="https://go.dev/tour/concurrency/1"><img class="center" src="gotour_concurrency_1.png"/></a></div>
</div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; Concurrency constructs</em><em class="next" onclick="nextPage()">Concurrency constructs Channels &raquo;</em>4/25</div>
</div>
<div class="page" id="5"><div class="view"><div class="header"><div class="group">Concurrency constructs</div>
<h3>Channels</h3>
</div>
<div class="slide"><div style="position: absolute; left: 25vw; width: 50vw"><a target="_blank" href="https://go.dev/tour/concurrency/2"><img class="center" src="gotour_concurrency_2.png"/></a></div>
</div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; Concurrency constructs Go routines</em><em class="next" onclick="nextPage()">Concurrency constructs Package sync &raquo;</em>5/25</div>
</div>
<div class="page" id="6"><div class="view"><div class="header"><div class="group">Concurrency constructs</div>
<h3>Package sync</h3>
</div>
<div class="slide"><div style="position: absolute; left: 30vw; width: 40vw"><div style="font-size:1.1vw"><pre><span class="keyword">package</span> sync <span class="comment">// import "sync"</span>

Package sync provides basic synchronization primitives such as mutual exclusion
locks. Other than the Once and WaitGroup types, most are intended for use by
low-level library routines. Higher-level synchronization is better done via
channels and communication.

Values containing the types defined in this package should not be copied.

<span class="keyword">func</span> OnceFunc(f <span class="keyword">func</span>()) <span class="keyword">func</span>()
<span class="keyword">func</span> OnceValue[T any](f <span class="keyword">func</span>() T) <span class="keyword">func</span>() T
<span class="keyword">func</span> OnceValues[T1, T2 any](f <span class="keyword">func</span>() (T1, T2)) <span class="keyword">func</span>() (T1, T2)
<span class="keyword">type</span> Cond <span class="keyword">struct</span>{ ... }
    <span class="keyword">func</span> NewCond(l Locker) *Cond
<span class="keyword">type</span> Locker <span class="keyword">interface</span>{ ... }
<span class="keyword">type</span> Map <span class="keyword">struct</span>{ ... }
<span class="keyword">type</span> Mutex <span class="keyword">struct</span>{ ... }
<span class="keyword">type</span> Once <span class="keyword">struct</span>{ ... }
<span class="keyword">type</span> Pool <span class="keyword">struct</span>{ ... }
<span class="keyword">type</span> RWMutex <span class="keyword">struct</span>{ ... }
<span class="keyword">type</span> WaitGroup <span class="keyword">struct</span>{ ... }
</pre><a target="_blank" href="https://pkg.go.dev/sync">pkg.go.dev/sync</a></div>
</div>
</div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; Concurrency constructs Channels</em><em class="next" onclick="nextPage()">Concurrency constructs Package context &raquo;</em>6/25</div>
</div>
<div class="page" id="7"><div class="view"><div class="header"><div class="group">Concurrency constructs</div>
<h3>Package context</h3>
</div>
<div class="slide"><div class="double"><div class="column left" style="width: 37vw"><pre style="font-size:0.8vw"><span class="keyword">package</span> context

...

Programs that use Contexts should follow these rules

Do not store Contexts inside a <span class="keyword">struct</span> <span class="keyword">type</span>; instead, pass a Context
explicitly to each function that needs it. The Context should be the
first parameter, typically named ctx:

<span class="keyword">func</span> DoSomething(ctx context.Context, arg Arg) error {
	<span class="comment">// ... use ctx ...</span>
}

Do not pass a nil Context, even if a function permits it. Pass
context.TODO if you are unsure about which Context to use.

Use context Values only for request-scoped data that transits
processes and APIs, not for passing optional parameters to functions.
		</pre></div>
<div class="column right" style="left: 45vw; width: 55vw"><div style="font-size:0.8vw"><pre>var Canceled = errors.New("context canceled")
var DeadlineExceeded error = deadlineExceededError{}
<span class="keyword">func</span> AfterFunc(ctx Context, f <span class="keyword">func</span>()) (stop <span class="keyword">func</span>() bool)
<span class="keyword">func</span> Cause(c Context) error
<span class="keyword">func</span> WithCancel(parent Context) (ctx Context, cancel CancelFunc)
<span class="keyword">func</span> WithCancelCause(parent Context) (ctx Context, cancel CancelCauseFunc)
<span class="keyword">func</span> WithDeadline(parent Context, d time.Time) (Context, CancelFunc)
<span class="keyword">func</span> WithDeadlineCause(parent Context, d time.Time, cause error) (Context, CancelFunc)
<span class="keyword">func</span> WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
<span class="keyword">func</span> WithTimeoutCause(parent Context, timeout time.Duration, cause error) (Context, CancelFunc)
<span class="keyword">type</span> CancelCauseFunc <span class="keyword">func</span>(cause error)
<span class="keyword">type</span> CancelFunc <span class="keyword">func</span>()
<span class="keyword">type</span> Context <span class="keyword">interface</span>{ ... }
    <span class="keyword">func</span> Background() Context
    <span class="keyword">func</span> TODO() Context
    <span class="keyword">func</span> WithValue(parent Context, key, val any) Context
    <span class="keyword">func</span> WithoutCancel(parent Context) Context
</pre><a target="_blank" href="https://pkg.go.dev/context">pkg.go.dev/context</a></div>
</div>
</div>
</div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; Concurrency constructs Package sync</em><em class="next" onclick="nextPage()">go test -bench &raquo;</em>7/25</div>
</div>
<div class="page" id="8"><div class="view"><div class="header"><h2>go test -bench</h2>
</div>
<div class="slide"><div class="double"><div class="column left" style="width: 37vw"><div class="srcfile"><code><ol>
<li><span class="keyword">package</span> main</li>
<li></li>
<li><span class="keyword">import</span> (</li>
<li>    "fmt"</li>
<li>    "testing"</li>
<li>    "time"</li>
<li>)</li>
<li></li>
<li><span class="keyword">func</span> BenchmarkX(b *testing.B) {</li>
<li>    fmt.Println("N is", b.N)</li>
<li>    <span class="keyword">for</span> i := 0; i < b.N; i++ {</li>
<li>        X()</li>
<li>    }</li>
<li>}</li>
<li></li>
<li><span class="keyword">func</span> X() {</li>
<li>    time.Sleep(time.Millisecond)</li>
<li>}</li>
</ol>
</code></div>
</div>
<div class="column right" style="left: 45vw; width: 55vw"><pre class="shell dark">$ go test -bench=BenchmarkX -v<br/>goos: linux
goarch: amd64
pkg: github.com/preferit/main
cpu: Intel(R) Xeon(R) E-2288G CPU @ 3.70GHz
BenchmarkX
N is 1
N is 100
N is 1100
BenchmarkX-16    	    1100	   1095229 ns/op
<span style="color:green;">PASS</span>
ok  	github.com/preferit/main	1.320s
</pre></div>
</div>
</div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; Concurrency constructs Package context</em><em class="next" onclick="nextPage()">Problem &raquo;</em>8/25</div>
</div>
<div class="page" id="9"><div class="view"><div class="header"><h2>Problem</h2>
</div>
<div class="slide"><div style="position: absolute; left: 22vw; width: 55vw"><div class="srcfile"><code><ol>
<li><span class="keyword">package</span> main</li>
<li></li>
<li><span class="keyword">import</span> (</li>
<li>    "net/http"</li>
<li>)</li>
<li></li>
<li><span class="comment">// Problem defines the thing that needs to be solved</span></li>
<li><span class="keyword">type</span> Problem <span class="keyword">interface</span> {</li>
<li>    <span class="comment">// Solve returns an error <span class="keyword">if</span> the given algorithm does not solve</span></li>
<li>    <span class="comment">// the problem.</span></li>
<li>    Solve(Algorithm) error</li>
<li>}</li>
<li></li>
<li><span class="comment">// Algorithm is any <span class="keyword">func</span> that takes some work and returns it's result.</span></li>
<li><span class="comment">// The validity of the result must be verified outside.</span></li>
<li><span class="keyword">type</span> Algorithm <span class="keyword">func</span>(work []*<span class="type">http.Request</span>) (result []*http.Response)</li>
</ol>
</code></div>
</div>
</div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; go test -bench</em><em class="next" onclick="nextPage()">Problem The letter challenge &raquo;</em>9/25</div>
</div>
<div class="page" id="10"><div class="view"><div class="header"><div class="group">Problem</div>
<h3>The letter challenge</h3>
</div>
<div class="slide"><div class="double"><div class="column left" style="width: 42vw"><div class="srcfile" style="font-size:1.1vw"><code><ol start="13">
<li><span class="comment">// NewLetterChallenge returns a problem defined as</span></li>
<li><span class="comment">//</span></li>
<li><span class="comment">//   - get all letters using a list of requests</span></li>
<li><span class="comment">//   - in the given order</span></li>
<li><span class="comment">//</span></li>
<li><span class="comment">// letters should be a space separated string of letters</span></li>
<li><span class="keyword">func</span> NewLetterChallenge(letters string) *OrderedLetters {</li>
<li>    <span class="keyword">return</span> &OrderedLetters{</li>
<li>        exp: letters,</li>
<li>    }</li>
<li>}</li>
<li></li>
<li><span class="keyword">type</span> OrderedLetters <span class="keyword">struct</span> {</li>
<li>    url string</li>
<li>    exp string</li>
<li>}</li>
<li></li>
<li><span class="keyword">func</span> (p *OrderedLetters) Server() *httptest.Server {</li>
<li>    handler := <span class="keyword">func</span>(w <span class="type">http.ResponseWriter</span>, r *<span class="type">http.Request</span>) {</li>
<li>        <-time.After(10 * time.Millisecond)</li>
<li>        w.Write([]byte(r.URL.Path[1:]))</li>
<li>    }</li>
<li>    srv := httptest.NewServer(http.HandlerFunc(handler))</li>
<li>    p.url = srv.URL</li>
<li>    <span class="keyword">return</span> srv</li>
<li>}</li>
</ol>
</code></div>
</div>
<div class="column right" style="left: 50vw; width: 50vw"><div class="srcfile" style="font-size:0.95vw"><code><ol start="40">
<li><span class="keyword">func</span> (p *OrderedLetters) Solve(alg Algorithm) error {</li>
<li>    <span class="comment">// create the workload, ie. requests</span></li>
<li>    words := strings.Split(p.exp, " ")</li>
<li>    work := make([]*<span class="type">http.Request</span>, len(words))</li>
<li>    <span class="keyword">for</span> i, word := <span class="keyword">range</span> words {</li>
<li>        work[i], _ = http.NewRequest("GET", p.url+"/"+word, http.NoBody)</li>
<li>    }</li>
<li></li>
<li>    <span class="comment">// run the algorithm</span></li>
<li>    result := alg(work)</li>
<li></li>
<li>    <span class="comment">// verify the result</span></li>
<li>    <span class="keyword">return</span> p.verify(work, result)</li>
<li>}</li>
<li></li>
<li><span class="keyword">func</span> (p *OrderedLetters) verify(work []*<span class="type">http.Request</span>, result []*http.Response) error {</li>
<li>    got := make([]string, 0, len(result))</li>
<li>    <span class="keyword">for</span> _, resp := <span class="keyword">range</span> result {</li>
<li>        <span class="keyword">if</span> resp != nil {</li>
<li>            <span class="keyword">var</span> buf bytes.Buffer</li>
<li>            io.Copy(&buf, resp.Body)</li>
<li>            resp.Body.Close()</li>
<li>            got = append(got, buf.String())</li>
<li>        } <span class="keyword">else</span> {</li>
<li>            got = append(got, " ") <span class="comment">// makes it easier to see</span></li>
<li>        }</li>
<li>    }</li>
<li>    <span class="keyword">if</span> got := strings.Join(got, " "); p.exp != got {</li>
<li>        <span class="keyword">return</span> fmt.Errorf("\nexp: %s\ngot: %s", p.exp, got)</li>
<li>    }</li>
<li>    <span class="keyword">return</span> nil</li>
<li>}</li>
</ol>
</code></div>
</div>
</div>
</div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; Problem</em><em class="next" onclick="nextPage()">Problem Verification &raquo;</em>10/25</div>
</div>
<div class="page" id="11"><div class="view"><div class="header"><div class="group">Problem</div>
<h3>Verification</h3>
</div>
<div class="slide"><p>Each algorithm in these examples is tested like this</p>
<div class="srcfile"><code><ol start="10">
<li><span class="keyword">const</span> Letters = "0 1 2 3 4 5 6 7 8 9 a b c d e f"</li>
<li></li>
<li><span class="keyword">func</span> BenchmarkAlg01(b *testing.B) {</li>
<li>    <span class="comment">// setup problem outside the loop</span></li>
<li>    problem := NewLetterChallenge(Letters)</li>
<li>    srv := problem.Server()</li>
<li>    <span class="keyword">defer</span> srv.Close()</li>
<li>    b.ResetTimer()</li>
<li></li>
<li>    <span class="keyword">for</span> i := 0; i < b.N; i++ {</li>
<li>        <span class="keyword">if</span> err := problem.Solve(Alg01); err != nil {</li>
<li>            b.Fatal(err)</li>
<li>        }</li>
<li>    }</li>
<li>}</li>
</ol>
</code></div>
</div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; Problem The letter challenge</em><em class="next" onclick="nextPage()">Problem Sequential &raquo;</em>11/25</div>
</div>
<div class="page" id="12"><div class="view"><div class="header"><div class="group">Problem</div>
<h3>Sequential</h3>
</div>
<div class="slide"><p>Simple implementation though very low performance</p>
<div class="double"><div class="column left" style="width: 47vw"><div class="srcfile" style="font-size:1.1vw"><code><ol start="9">
<li><span class="comment">// Alg01 solves the work sequentially</span></li>
<li><span class="keyword">func</span> Alg01(work []*<span class="type">http.Request</span>) []*http.Response {</li>
<li>    result := make([]*http.Response, 0, len(work))</li>
<li>    <span class="keyword">for</span> _, r := <span class="keyword">range</span> work {</li>
<li>        resp, err := http.DefaultClient.Do(r)</li>
<li>        <span class="keyword">if</span> err != nil {</li>
<li>            panic(err.Error())</li>
<li>        }</li>
<li>        result = append(result, resp)</li>
<li>    }</li>
<li>    <span class="keyword">return</span> result</li>
<li>}</li>
</ol>
</code></div>
</div>
<div class="column right" style="left: 55vw; width: 45vw"><div><pre class="shell dark" style="font-size: 1.0vw">$ go test -benchmem -bench=BenchmarkAlg01<br/>goos: linux
goarch: amd64
pkg: github.com/gregoryv/cotalk
cpu: 13th Gen Intel(R) Core(TM) i7-1365U
BenchmarkAlg01-12    	       6	 185478241 ns/op	  347652 B/op	    2072 allocs/op
<span style="color:green;">PASS</span>
ok  	github.com/gregoryv/cotalk	1.313s
</pre></div>
</div>
</div>
</div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; Problem Verification</em><em class="next" onclick="nextPage()">Concurrent using sync.WaitGroup &raquo;</em>12/25</div>
</div>
<div class="page" id="13"><div class="view"><div class="header"><h2>Concurrent using sync.WaitGroup</h2>
</div>
<div class="slide"><div class="double"><div class="column left" style="width: 47vw"><div class="srcfile" style="font-size:1.1vw"><code><ol start="22">
<li><span class="comment">// Alg02 uses sync.WaitGroup to wait <span class="keyword">for</span> all responses</span></li>
<li><span class="keyword">func</span> Alg02(work []*<span class="type">http.Request</span>) (result []*http.Response) {</li>
<li>    <span class="keyword">var</span> wg sync.WaitGroup</li>
<li>    <span class="keyword">for</span> _, r := <span class="keyword">range</span> work {</li>
<li>        wg.Add(1)</li>
<li>        <span class="keyword">go</span> <span class="keyword">func</span>() {</li>
<li>            resp, _ := http.DefaultClient.Do(r)</li>
<li>            result = append(result, resp)</li>
<li>            wg.Done()</li>
<li>        }()</li>
<li>    }</li>
<li>    wg.Wait()</li>
<li>    <span class="keyword">return</span></li>
<li>}</li>
</ol>
</code></div>
</div>
<div class="column right" style="left: 55vw; width: 45vw"><div><pre class="shell dark" style="font-size: 1.0vw">$ go test -benchmem -bench=BenchmarkAlg02<br/><span style="color:red;">--- FAIL:</span> BenchmarkAlg02
    alg_test.go:34: 
        exp: 0 1 2 3 4 5 6 7 8 9 a b c d e f
        got: f f f f f f f f f f f f f f f f
<span style="color:red;">FAIL</span>
exit status 1
<span style="color:red;">FAIL</span>	github.com/gregoryv/cotalk	0.014s
<span style="color:red;">FAIL</span>
</pre><p>Why does it fail?</p>
</div>
</div>
</div>
</div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; Problem Sequential</em><em class="next" onclick="nextPage()">Concurrent using sync.WaitGroup Go 1.23 &raquo;</em>13/25</div>
</div>
<div class="page" id="14"><div class="view"><div class="header"><h2>Concurrent using sync.WaitGroup Go 1.23</h2>
</div>
<div class="slide"><div class="double"><div class="column left" style="width: 47vw"><div class="srcfile" style="font-size:1.1vw"><code><ol start="22">
<li><span class="comment">// Alg02 uses sync.WaitGroup to wait <span class="keyword">for</span> all responses</span></li>
<li><span class="keyword">func</span> Alg02(work []*<span class="type">http.Request</span>) (result []*http.Response) {</li>
<li>    <span class="keyword">var</span> wg sync.WaitGroup</li>
<li>    <span class="keyword">for</span> _, r := <span class="keyword">range</span> work {</li>
<li>        wg.Add(1)</li>
<li>        <span class="keyword">go</span> <span class="keyword">func</span>() {</li>
<li>            resp, _ := http.DefaultClient.Do(r)</li>
<li>            result = append(result, resp)</li>
<li>            wg.Done()</li>
<li>        }()</li>
<li>    }</li>
<li>    wg.Wait()</li>
<li>    <span class="keyword">return</span></li>
<li>}</li>
</ol>
</code></div>
</div>
<div class="column right" style="left: 55vw; width: 45vw"><pre class="shell dark" style="font-size: 1vw">$ go1.23 test -benchmem -bench=BenchmarkAlg02<br/><span style="color:red;">--- FAIL:</span> BenchmarkAlg02
    alg_test.go:34: 
        exp: 0 1 2 3 4 5 6 7 8 9 a b c d e f
        got: 5 3 9 c 1 d a b 4 8 e 6 f 7 2 0
<span style="color:red;">FAIL</span>
exit status 1
<span style="color:red;">FAIL</span>	github.com/gregoryv/cotalk	0.019s
<span style="color:red;">FAIL</span>
</pre><p>Fixed!</p>
</div>
</div>
</div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; Concurrent using sync.WaitGroup</em><em class="next" onclick="nextPage()">Arguments are evaluated at calltime &raquo;</em>14/25</div>
</div>
<div class="page" id="15"><div class="view"><div class="header"><h2>Arguments are evaluated at calltime</h2>
</div>
<div class="slide"><div class="double"><div class="column left" style="width: 47vw"><div class="srcfile" style="font-size:1.1vw"><code><ol start="37">
<li><span class="comment">// Alg03 fixes reference problem inside loop</span></li>
<li><span class="keyword">func</span> Alg03(work []*<span class="type">http.Request</span>) (result []*http.Response) {</li>
<li>    <span class="keyword">var</span> wg sync.WaitGroup</li>
<li>    <span class="keyword">for</span> _, r := <span class="keyword">range</span> work {</li>
<li>        wg.Add(1)</li>
<li>        <span class="keyword">go</span> <span class="keyword">func</span>(lr *<span class="type">http.Request</span>) {</li>
<li>            <span class="comment">// use local argument</span></li>
<li>            resp, _ := http.DefaultClient.Do(lr)</li>
<li>            result = append(result, resp)</li>
<li>            wg.Done()</li>
<li>        }(r) <span class="comment">// make a copy of pointer with argument</span></li>
<li>    }</li>
<li>    wg.Wait()</li>
<li>    <span class="keyword">return</span></li>
<li>}</li>
</ol>
</code></div>
</div>
<div class="column right" style="left: 55vw; width: 45vw"><div><pre class="shell dark" style="font-size: 1.0vw">$ go test -benchmem -bench=BenchmarkAlg03<br/><span style="color:red;">--- FAIL:</span> BenchmarkAlg03
    alg_test.go:47: 
        exp: 0 1 2 3 4 5 6 7 8 9 a b c d e f
        got: 6 0 4 1 5 d 2 c 3 f 7 a 8 e b 9
<span style="color:red;">FAIL</span>
exit status 1
<span style="color:red;">FAIL</span>	github.com/gregoryv/cotalk	0.018s
<span style="color:red;">FAIL</span>
</pre><p>You might get a different result; why does it still fail? and can the tooling help identify the problem, try <pre class="shell dark" style="font-size: 1vw">$ go test -benchmem -bench=BenchmarkAlg03 -race -count 1</pre></p>
</div>
</div>
</div>
</div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; Concurrent using sync.WaitGroup Go 1.23</em><em class="next" onclick="nextPage()">Protect concurrent writes with sync.Mutex &raquo;</em>15/25</div>
</div>
<div class="page" id="16"><div class="view"><div class="header"><h2>Protect concurrent writes with sync.Mutex</h2>
</div>
<div class="slide"><div class="double"><div class="column left" style="width: 47vw"><div class="srcfile" style="font-size:1.1vw"><code><ol start="53">
<li><span class="comment">// Alg04 synchronizes writes accross <span class="keyword">go</span> routines</span></li>
<li><span class="keyword">func</span> Alg04(work []*<span class="type">http.Request</span>) (result []*http.Response) {</li>
<li>    <span class="keyword">var</span> wg sync.WaitGroup</li>
<li>    <span class="keyword">var</span> m sync.Mutex</li>
<li>    <span class="keyword">for</span> _, r := <span class="keyword">range</span> work {</li>
<li>        wg.Add(1)</li>
<li>        <span class="keyword">go</span> <span class="keyword">func</span>(lr *<span class="type">http.Request</span>) {</li>
<li>            resp, _ := http.DefaultClient.Do(lr)</li>
<li>            <span class="comment">// protect result</span></li>
<li>            m.Lock()</li>
<li>            result = append(result, resp)</li>
<li>            m.Unlock()</li>
<li>            wg.Done()</li>
<li>        }(r)</li>
<li>    }</li>
<li>    wg.Wait()</li>
<li>    <span class="keyword">return</span></li>
<li>}</li>
</ol>
</code></div>
</div>
<div class="column right" style="left: 55vw; width: 45vw"><div><pre class="shell dark" style="font-size: 1.0vw">$ go test -benchmem -bench=BenchmarkAlg04<br/><span style="color:red;">--- FAIL:</span> BenchmarkAlg04
    alg_test.go:60: 
        exp: 0 1 2 3 4 5 6 7 8 9 a b c d e f
        got: d b e 8 3 5 4 a 0 6 2 7 9 c f 1
<span style="color:red;">FAIL</span>
exit status 1
<span style="color:red;">FAIL</span>	github.com/gregoryv/cotalk	0.017s
<span style="color:red;">FAIL</span>
</pre><p>Why does it fail?</p>
</div>
</div>
</div>
</div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; Arguments are evaluated at calltime</em><em class="next" onclick="nextPage()">Sort results &raquo;</em>16/25</div>
</div>
<div class="page" id="17"><div class="view"><div class="header"><h2>Sort results</h2>
</div>
<div class="slide"><div class="double"><div class="column left" style="width: 47vw"><div class="srcfile" style="font-size:1.1vw"><code><ol start="72">
<li><span class="comment">// Alg05 fix order</span></li>
<li><span class="keyword">func</span> Alg05(work []*<span class="type">http.Request</span>) (result []*http.Response) {</li>
<li>    <span class="keyword">var</span> wg sync.WaitGroup</li>
<li>    <span class="keyword">var</span> m sync.Mutex</li>
<li>    result = make([]*http.Response, len(work))</li>
<li>    <span class="keyword">for</span> i, r := <span class="keyword">range</span> work {</li>
<li>        wg.Add(1)</li>
<li>        <span class="keyword">go</span> <span class="keyword">func</span>(i int, lr *<span class="type">http.Request</span>) {</li>
<li>            resp, _ := http.DefaultClient.Do(lr)</li>
<li>            <span class="comment">// protect result</span></li>
<li>            m.Lock()</li>
<li>            result[i] = resp</li>
<li>            m.Unlock()</li>
<li>            wg.Done()</li>
<li>        }(i, r)</li>
<li>    }</li>
<li>    wg.Wait()</li>
<li>    <span class="keyword">return</span></li>
<li>}</li>
</ol>
</code></div>
</div>
<div class="column right" style="left: 55vw; width: 45vw"><div><pre class="shell dark" style="font-size: 1.0vw">$ go test -benchmem -bench=BenchmarkAlg05<br/>goos: linux
goarch: amd64
pkg: github.com/gregoryv/cotalk
cpu: 13th Gen Intel(R) Core(TM) i7-1365U
BenchmarkAlg05-12    	     100	  13075594 ns/op	  289386 B/op	    2040 allocs/op
<span style="color:green;">PASS</span>
ok  	github.com/gregoryv/cotalk	1.326s
</pre></div>
</div>
</div>
</div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; Protect concurrent writes with sync.Mutex</em><em class="next" onclick="nextPage()">Improved performance paid with complexity &raquo;</em>17/25</div>
</div>
<div class="page" id="18"><div class="view"><div class="header"><h2>Improved performance paid with complexity</h2>
</div>
<div class="slide"><p>Comparing the sequential working algorithm to the working
		concurrent one, tests reveal a substantial improvement.</p>
<pre class="shell dark">$ go test -benchmem -bench="(Alg01|Alg05)$"<br/>goos: linux
goarch: amd64
pkg: github.com/preferit/main
cpu: Intel(R) Xeon(R) E-2288G CPU @ 3.70GHz
BenchmarkAlg1-16    	       6	 175609134 ns/op	  276349 B/op	    1976 allocs/op
BenchmarkAlg5-16    	      87	  13308022 ns/op	  292652 B/op	    2021 allocs/op
<span style="color:green;">PASS</span>
ok  	github.com/preferit/main	2.413s
</pre></div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; Sort results</em><em class="next" onclick="nextPage()">Using channel &raquo;</em>18/25</div>
</div>
<div class="page" id="19"><div class="view"><div class="header"><h2>Using channel</h2>
</div>
<div class="slide"><div class="double"><div class="column left" style="width: 47vw"><div class="srcfile" style="font-size:1.1vw"><code><ol start="92">
<li><span class="comment">// Alg06 uses channel to synchronize responses</span></li>
<li><span class="keyword">func</span> Alg06(work []*<span class="type">http.Request</span>) (result []*http.Response) {</li>
<li>    c := make(chan *http.Response)</li>
<li>    <span class="keyword">for</span> _, r := <span class="keyword">range</span> work {</li>
<li>        <span class="keyword">go</span> <span class="keyword">func</span>(lr *<span class="type">http.Request</span>) {</li>
<li>            resp, _ := http.DefaultClient.Do(lr)</li>
<li>            c <- resp <span class="comment">// write to channel</span></li>
<li>        }(r)</li>
<li>    }</li>
<li>    <span class="keyword">for</span> <span class="keyword">range</span> work {</li>
<li>        resp := <-c <span class="comment">// read from channel</span></li>
<li>        result = append(result, resp)</li>
<li>    }</li>
<li>    <span class="keyword">return</span></li>
<li>}</li>
</ol>
</code></div>
</div>
<div class="column right" style="left: 55vw; width: 45vw"><div><pre class="shell dark" style="font-size: 1.0vw">$ go test -benchmem -bench=BenchmarkAlg06<br/><span style="color:red;">--- FAIL:</span> BenchmarkAlg06
    alg_test.go:86: 
        exp: 0 1 2 3 4 5 6 7 8 9 a b c d e f
        got: a 0 e c d 8 5 b 9 2 3 4 1 6 f 7
<span style="color:red;">FAIL</span>
exit status 1
<span style="color:red;">FAIL</span>	github.com/gregoryv/cotalk	0.017s
<span style="color:red;">FAIL</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; Improved performance paid with complexity</em><em class="next" onclick="nextPage()">Using channel Correct order using channel &raquo;</em>19/25</div>
</div>
<div class="page" id="20"><div class="view"><div class="header"><div class="group">Using channel</div>
<h3>Correct order using channel</h3>
</div>
<div class="slide"><div class="double"><div class="column left" style="width: 47vw"><div class="srcfile" style="font-size:1.1vw"><code><ol start="108">
<li><span class="comment">// Alg07 uses channel to synchronize responses with ordered result</span></li>
<li><span class="keyword">func</span> Alg07(work []*<span class="type">http.Request</span>) (result []*http.Response) {</li>
<li>    <span class="keyword">type</span> m <span class="keyword">struct</span> {</li>
<li>        index int</li>
<li>        *http.Response</li>
<li>    }</li>
<li>    c := make(chan m)</li>
<li>    result = make([]*http.Response, len(work))</li>
<li>    <span class="keyword">for</span> i, r := <span class="keyword">range</span> work {</li>
<li>        <span class="keyword">go</span> <span class="keyword">func</span>(i int, lr *<span class="type">http.Request</span>) {</li>
<li>            resp, _ := http.DefaultClient.Do(lr)</li>
<li>            c <- m{i, resp} <span class="comment">// write to channel</span></li>
<li>        }(i, r)</li>
<li>    }</li>
<li>    <span class="keyword">for</span> <span class="keyword">range</span> work {</li>
<li>        v := <-c <span class="comment">// read from channel</span></li>
<li>        result[v.index] = v.Response</li>
<li>    }</li>
<li>    <span class="keyword">return</span></li>
<li>}</li>
</ol>
</code></div>
</div>
<div class="column right" style="left: 55vw; width: 45vw"><div><pre class="shell dark" style="font-size: 1.0vw">$ go test -benchmem -bench=BenchmarkAlg07<br/>goos: linux
goarch: amd64
pkg: github.com/gregoryv/cotalk
cpu: 13th Gen Intel(R) Core(TM) i7-1365U
BenchmarkAlg07-12    	     100	  13268373 ns/op	  355180 B/op	    2059 allocs/op
<span style="color:green;">PASS</span>
ok  	github.com/gregoryv/cotalk	1.345s
</pre><p>There is still a bug in this code, do you see it?</p>
</div>
</div>
</div>
</div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; Using channel</em><em class="next" onclick="nextPage()">Clean up resources &raquo;</em>20/25</div>
</div>
<div class="page" id="21"><div class="view"><div class="header"><h2>Clean up resources</h2>
</div>
<div class="slide"><div class="double"><div class="column left" style="width: 47vw"><div class="srcfile" style="font-size:1.1vw"><code><ol start="129">
<li><span class="comment">// Alg08 uses channel to synchronize responses with ordered result</span></li>
<li><span class="keyword">func</span> Alg08(work []*<span class="type">http.Request</span>) (result []*http.Response) {</li>
<li>    <span class="keyword">type</span> m <span class="keyword">struct</span> {</li>
<li>        index int</li>
<li>        *http.Response</li>
<li>    }</li>
<li>    c := make(chan m)</li>
<li>    <span class="keyword">defer</span> close(c) <span class="comment">// make sure you clean up when done</span></li>
<li>    result = make([]*http.Response, len(work))</li>
<li>    <span class="keyword">for</span> i, r := <span class="keyword">range</span> work {</li>
<li>        <span class="keyword">go</span> <span class="keyword">func</span>(i int, lr *<span class="type">http.Request</span>) {</li>
<li>            resp, _ := http.DefaultClient.Do(lr)</li>
<li>            c <- m{i, resp} <span class="comment">// write to channel</span></li>
<li>        }(i, r)</li>
<li>    }</li>
<li>    <span class="keyword">for</span> <span class="keyword">range</span> work {</li>
<li>        v := <-c <span class="comment">// read from channel</span></li>
<li>        result[v.index] = v.Response</li>
<li>    }</li>
<li>    <span class="keyword">return</span></li>
<li>}</li>
</ol>
</code></div>
</div>
<div class="column right" style="left: 55vw; width: 45vw"><div><pre class="shell dark" style="font-size: 1.0vw">$ go test -benchmem -bench=BenchmarkAlg08<br/>goos: linux
goarch: amd64
pkg: github.com/gregoryv/cotalk
cpu: 13th Gen Intel(R) Core(TM) i7-1365U
BenchmarkAlg08-12    	      91	  13029390 ns/op	  298092 B/op	    2043 allocs/op
<span style="color:green;">PASS</span>
ok  	github.com/gregoryv/cotalk	1.208s
</pre></div>
</div>
</div>
</div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; Using channel Correct order using channel</em><em class="next" onclick="nextPage()">Interrupt &raquo;</em>21/25</div>
</div>
<div class="page" id="22"><div class="view"><div class="header"><h2>Interrupt</h2>
</div>
<div class="slide"><div class="double"><div class="column left" style="width: 47vw"><div class="srcfile" style="font-size:1.0vw"><code><ol start="151">
<li><span class="comment">// Alg09 returns when all work is done or context is cancelled</span></li>
<li><span class="keyword">func</span> Alg09(ctx context.Context, work []*<span class="type">http.Request</span>) (result []*http.Response) {</li>
<li>    <span class="keyword">type</span> m <span class="keyword">struct</span> {</li>
<li>        index int</li>
<li>        *http.Response</li>
<li>    }</li>
<li>    c := make(chan m)</li>
<li>    complete := make(chan <span class="keyword">struct</span>{})</li>
<li>    <span class="keyword">defer</span> close(c) <span class="comment">// make sure you clean up when done</span></li>
<li>    result = make([]*http.Response, len(work))</li>
<li>    <span class="keyword">go</span> <span class="keyword">func</span>() {</li>
<li>        <span class="keyword">defer</span> close(complete)</li>
<li>        <span class="keyword">for</span> i, r := <span class="keyword">range</span> work {</li>
<li>            <span class="keyword">go</span> <span class="keyword">func</span>(i int, lr *<span class="type">http.Request</span>) {</li>
<li>                resp, _ := http.DefaultClient.Do(lr)</li>
<li>                c <- m{i, resp} <span class="comment">// write to channel</span></li>
<li>            }(i, r)</li>
<li>        }</li>
<li>        <span class="keyword">for</span> <span class="keyword">range</span> work {</li>
<li>            v := <-c <span class="comment">// read from channel</span></li>
<li>            result[v.index] = v.Response</li>
<li>        }</li>
<li>    }()</li>
<li>    <span class="keyword">select</span> {</li>
<li>    <span class="keyword">case</span> <-ctx.Done():</li>
<li>        <span class="comment">// interrupted</span></li>
<li>    <span class="keyword">case</span> <-complete:</li>
<li>    }</li>
<li>    <span class="keyword">return</span></li>
<li>}</li>
</ol>
</code></div>
</div>
<div class="column right" style="left: 55vw; width: 45vw"><div><pre class="shell dark" style="font-size: 1.0vw">$ go test -benchmem -bench=BenchmarkAlg09<br/>goos: linux
goarch: amd64
pkg: github.com/gregoryv/cotalk
cpu: 13th Gen Intel(R) Core(TM) i7-1365U
BenchmarkAlg09-12    	panic: send on closed channel

goroutine 332 [running]:
github.com/gregoryv/cotalk.Alg09.func1.1(0x8, 0x0?)
	<span style="color:teal;">/home/grevin/edu/cotalk/alg.go</span>:166 +0x49
created by github.com/gregoryv/cotalk.Alg09.func1 in goroutine 323
	<span style="color:teal;">/home/grevin/edu/cotalk/alg.go</span>:164 +0x85
exit status 2
<span style="color:red;">FAIL</span>	github.com/gregoryv/cotalk	0.048s
<span style="color:red;">FAIL</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; Clean up resources</em><em class="next" onclick="nextPage()">Respect context cancellation &raquo;</em>22/25</div>
</div>
<div class="page" id="23"><div class="view"><div class="header"><h2>Respect context cancellation</h2>
</div>
<div class="slide"><div class="double"><div class="column left" style="width: 47vw"><div class="srcfile" style="font-size:1.0vw"><code><ol start="182">
<li><span class="comment">// Alg10 returns when all work is done or context is cancelled</span></li>
<li><span class="keyword">func</span> Alg10(ctx context.Context, work []*<span class="type">http.Request</span>) (result []*http.Response) {</li>
<li>    <span class="keyword">type</span> m <span class="keyword">struct</span> {</li>
<li>        index int</li>
<li>        *http.Response</li>
<li>    }</li>
<li>    c := make(chan m)</li>
<li>    complete := make(chan <span class="keyword">struct</span>{})</li>
<li>    <span class="keyword">defer</span> close(c) <span class="comment">// make sure you clean up when done</span></li>
<li>    result = make([]*http.Response, len(work))</li>
<li>    <span class="keyword">go</span> <span class="keyword">func</span>() {</li>
<li>        <span class="keyword">defer</span> close(complete)</li>
<li>        <span class="keyword">for</span> i, r := <span class="keyword">range</span> work {</li>
<li>            <span class="keyword">go</span> <span class="keyword">func</span>(i int, lr *<span class="type">http.Request</span>) {</li>
<li>                resp, _ := http.DefaultClient.Do(lr)</li>
<li>                <span class="keyword">select</span> {</li>
<li>                <span class="keyword">case</span> <-ctx.Done():</li>
<li>                <span class="keyword">default</span>:</li>
<li>                    c <- m{i, resp} <span class="comment">// write to channel</span></li>
<li>                }</li>
<li>            }(i, r)</li>
<li>        }</li>
<li>        <span class="keyword">for</span> <span class="keyword">range</span> work {</li>
<li>            v := <-c <span class="comment">// read from channel</span></li>
<li>            result[v.index] = v.Response</li>
<li>        }</li>
<li>    }()</li>
<li>    <span class="keyword">select</span> {</li>
<li>    <span class="keyword">case</span> <-ctx.Done():</li>
<li>        <span class="comment">// interrupted</span></li>
<li>    <span class="keyword">case</span> <-complete:</li>
<li>    }</li>
<li>    <span class="keyword">return</span></li>
<li>}</li>
</ol>
</code></div>
</div>
<div class="column right" style="left: 55vw; width: 45vw"><div><pre class="shell dark" style="font-size: 1.0vw">$ go test -benchmem -bench=BenchmarkAlg10<br/>goos: linux
goarch: amd64
pkg: github.com/gregoryv/cotalk
cpu: 13th Gen Intel(R) Core(TM) i7-1365U
<span style="color:red;">BenchmarkAlg10-12    	--- FAIL:</span> BenchmarkAlg10-12
    alg_test.go:154: 
        exp: 0 1 2 3 4 5 6 7 8 9 a b c d e f
        got:   1     4     7                
<span style="color:red;">FAIL</span>
exit status 1
<span style="color:red;">FAIL</span>	github.com/gregoryv/cotalk	0.058s
<span style="color:red;">FAIL</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; Interrupt</em><em class="next" onclick="nextPage()">Compare all &raquo;</em>23/25</div>
</div>
<div class="page" id="24"><div class="view"><div class="header"><h2>Compare all</h2>
</div>
<div class="slide"><p>In this example using channels and sync package primitives
		seem to yield more or less the same result. There performance
		boost would be to try and minimize number of allocations. But
		that is out of scope for this talk.</p>
<pre class="shell dark">$ go test -benchmem -bench="(Alg01|Alg05|Alg08)$"<br/>goos: linux
goarch: amd64
pkg: github.com/preferit/main
cpu: Intel(R) Xeon(R) E-2288G CPU @ 3.70GHz
BenchmarkAlg1-16    	       6	 175310048 ns/op	  277350 B/op	    1982 allocs/op
BenchmarkAlg5-16    	      88	  13202327 ns/op	  293016 B/op	    2026 allocs/op
BenchmarkAlg8-16    	      91	  13449404 ns/op	  289586 B/op	    2019 allocs/op
<span style="color:green;">PASS</span>
ok  	github.com/preferit/main	3.652s
</pre></div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; Respect context cancellation</em><em class="next" onclick="nextPage()">Summary &raquo;</em>24/25</div>
</div>
<div class="page" id="25"><div class="view"><div class="header"><h2>Summary</h2>
</div>
<div class="slide"><div style="position: absolute; left: 19vw; width: 61vw"><ul>
<li>Concurrency is difficult to get right; even in Go</li>
<li>Tests are invaluable when debugging concurrency issues</li>
<li>Measure, never assume performance optimizations</li>
<li>If performance is good enough with a sequential algorithm, skip the complexity of concurrency</li>
</ul>
</div>
</div>
</div>
<div class="footer"><em class="prev" onclick="previousPage()">&laquo; Compare all</em><em class="next">&nbsp;</em>25/25</div>
</div>
</body>
<script>document.addEventListener('keydown', function(event) {
    if (previousPageKey(event)) {
	event.preventDefault()		
	previousPage()
	return
    }
    if (nextPageKey(event)) {
	event.preventDefault()
	nextPage()
	return
    }
    if (event.key === 'Home') {
	pageIndex = 1
	event.preventDefault()
	window.location.hash = pageIndex	
    }
    if (event.key === 'End') {
	pageIndex = last
	event.preventDefault()
	window.location.hash = pageIndex	
    }
    if (event.key === 't') {
	pageIndex = 2 // toc
	event.preventDefault()
	window.location.hash = pageIndex	
    }
    return
})

window.addEventListener('resize', function() {
    window.location.hash = getPos()
});

const last = document.querySelectorAll('.page').length;

function previousPage() {
    let pageIndex = getPos()
    if (pageIndex > 1) {
	pageIndex--
	window.location.hash = pageIndex
    }
}

function nextPage() {
    let pageIndex = getPos()
    if (pageIndex < last) {
	pageIndex++
	window.location.hash = pageIndex
    }
}

function previousPageKey(event) {
    return event.key === 'ArrowLeft' ||
	    event.key === 'ArrowUp' ||
	    event.key === 'PageUp'
}

function nextPageKey(event) {
    return event.key === 'ArrowRight' ||
	    event.key === 'ArrowDown' ||
	    event.key === 'PageDown'
}

function getPos() {
    let currentView = window.location.hash
    if (currentView === '') {
	currentView = "#1"
    }
    return parseInt(currentView.split('#').join(''))
}

// dots is an array of Dot objects,
var dots = [];

// mouse is an object used to track the X and Y position
// of the mouse, set with a mousemove event listener below
var mouse = { x: 0, y: 0 };

// visible indicates if trail is vissible or not
var visible = false;

addEventListener('keydown', function(event) {
    if (event.keyCode == 17 && !visible) {
	// show all dots
	visible = true;
	for ( let i = 0; i < dots.length; i++) {
	    dots[i].node.style.display = "block";
	};   
    }
});

addEventListener('keyup', function(event) {
    if (event.keyCode == 17 && visible) {
	// hide all dots
	visible = false;
	for ( let i = 0; i < dots.length; i++) {
	    dots[i].node.style.display = "none";
	};
    }
});

// The Dot object used to scaffold the dots
var Dot = function() {
  this.x = 0;
  this.y = 0;
  this.node = (function(){
    var n = document.createElement("div");
    n.className = "trail";
    document.body.appendChild(n);
    return n;
  }());
};
// The Dot.prototype.draw() method sets the position of 
  // the object's <div> node
Dot.prototype.draw = function() {
  this.node.style.left = this.x + "px";
  this.node.style.top = this.y + "px";
};


// Creates the Dot objects, populates the dots array
for (var i = 0; i < 12; i++) {
  var d = new Dot();
  dots.push(d);
}

// This is the screen redraw function
function draw() {
  // Make sure the mouse position is set everytime
    // draw() is called.
  var x = mouse.x,
      y = mouse.y;
  
  // This loop is where all the 90s magic happens
  dots.forEach(function(dot, index, dots) {
    var nextDot = dots[index + 1] || dots[0];
    
    dot.x = x;
    dot.y = y;
    dot.draw();
    x += (nextDot.x - dot.x) * .6;
    y += (nextDot.y - dot.y) * .6;

  });
}

addEventListener("mousemove", function(event) {
  event.preventDefault();
  mouse.x = event.pageX;
  mouse.y = event.pageY;
});


// animate() calls draw() then recursively calls itself
  // everytime the screen repaints via requestAnimationFrame().
function animate() {
    if (visible) {
	draw();
    }
  requestAnimationFrame(animate);
}



// And get it started by calling animate().
animate();
</script>
</html>
