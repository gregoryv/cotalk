<!DOCTYPE html>

<html>
<head>
<title>Go concurrency</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>html, body {
margin: 0 0;
padding: 0 0;
}
.slide {
padding: 10px 20%;
text-align: center;
height: calc( 100vh - 50px);
}
.slide ul, p, pre {
text-align: left;
font-size: 1.5vh;
}
.slide nav {
text-align: center;
float: left;
clear: both;
width: 100%;
display: block;
margin-top: 2em;
}
.slide nav ul {
list-style-type: none;
margin: 0 0;
padding: 0 0;
text-align: center;
}
.slide nav ul li {
margin: 0 1px;
display: inline;
}
.slide nav ul li.current a, .slide nav ul li:hover a {
background-color: #e2e2e2;
border-radius: 5px;
}
nav a:link, nav a:visited {
color: #727272;
padding: 3px 5px;
text-decoration: none;
cursor: pointer;
}
a:link, a:visited {
color: #007d9c;
text-decoration: none;
}
a:hover {
text-decoration: underline;
}
.header {
width: 100%;
border-bottom: 1px solid #727272;
text-align: right;
margin-top: -2em;
margin-bottom: 1em;
}
h1, h2, h3 {
text-align: center;
}
.srcfile {
margin-top: 1.6em;
margin-bottom: 1.6em;
background-image: url("printout-whole.png");
background-repeat: repeat-y;
padding-left: 36px;
background-color: #fafafa;
tab-size: 4;
-moz-tab-size: 4;
}
.srcfile code {
padding: .6em 0 2vh 0;
background-image: url("printout-whole.png");
background-repeat: repeat-y;
background-position: right top;
display: block;
text-align: left;
}
.srcfile code .line {
display: block;
width: 98%;
clear: both;
margin-bottom: -1.5vh;
}
.srcfile code span:hover {
background-color: wheat;
}
.srcfile code i {
font-style: normal;
color: #a2a2a2;
}
li.h3 {
margin-left: 2em;
}
.shell {
padding: 1em;
border-radius: 10px;
}
.dark {
background-color: #2e2e34;
color: aliceblue;
}
.light {
background-color: #ffffff;
color: #3b2616;
}
img.center {
display: block;
margin-left: auto;
margin-right: auto;
}
img.left {
float: left;
margin-right: 2em;
}
.group {
float: left;
text-align: left;
margin-right: 3em;
}
td {
vertical-align: top;
}
td:nth-child(2) {
padding-left: 2em;
}
.keyword {
color: darkviolet;
}
.type {
color: dodgerblue;
}
.comment, .comment>span {
color: darkgreen;
}
</style>
</head>
<body>
<div class="slide" id="1"><br/><a href="#2"><img src="cotalk.png"/></a><br/><br/><br/><span>Gregory Vinčić, 2023</span><br/><br/><br/><nav><ul>
<li class="current"><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="2"><h1>Content</h1>
<ul class="group">
<li>background and history</li>
<li>goroutines</li>
<li>channels</li>
<li>package context</li>
<li>package sync </li>
</ul>
<ul class="group">
<li>go test bench</li>
<li>problem definition</li>
<li>sequential solution</li>
</ul>
<ul class="group">
<li>concurrent solution</li>
<li>fixing bugs</li>
</ul>
<ul class="group">
<li>using channels</li>
<li>sync and interrupt</li>
<li>compare performance</li>
</ul>
<br clear="all"/><p>Follow along by cloning the examples with </p>
<pre class="shell dark">$ git clone git@github.com:preferit/cotalk.git
$ cd cotalk</pre><br clear="all"/><nav><ul>
<li><a href="#1">1</a></li>
<li class="current"><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="3"><h2>Background and history</h2>
<table>
<tr><td><img src="th_small.jpg"/></td><td><p>Sir Charles Antony Richard Hoare (<a href="https://en.wikipedia.org/wiki/Tony_Hoare">Tony Hoare</a>). Born 1934 in Sri Lanka, studied at Oxford and in
			Moscow. His research spanned program correctness, sorting
			and programming languages. His work is freely accessible
			online and the Go channel construct is his concept.
			</p>
<ul>
<li><a href="https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf">Communicating Sequential Processes (CSP), paper 1978</a></li>
<li><a href="http://www.usingcsp.com/cspbook.pdf">CSP, book 1985</a></li>
</ul>
</td></tr>
</table>
<nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li class="current"><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="4"><h2>Goroutines</h2>
<a target="_blank" href="https://go.dev/tour/concurrency/1"><img class="center" src="gotour_concurrency_1.png"/></a><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li class="current"><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="5"><h2>channels</h2>
<a target="_blank" href="https://go.dev/tour/concurrency/2"><img class="center" src="gotour_concurrency_2.png"/></a><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li class="current"><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="6"><h2>package sync</h2>
<pre><span class="keyword">package</span> sync <span class="comment">// import "sync"</span>

Package sync provides basic synchronization primitives such as mutual exclusion
locks. Other than the Once and WaitGroup types, most are intended for use by
low-level library routines. Higher-level synchronization is better done via
channels and communication.

Values containing the types defined in this package should not be copied.

<span class="keyword">type</span> Cond <span class="keyword">struct</span>{ ... }
    <span class="keyword">func</span> NewCond(l Locker) *Cond
<span class="keyword">type</span> Locker <span class="keyword">interface</span>{ ... }
<span class="keyword">type</span> Map <span class="keyword">struct</span>{ ... }
<span class="keyword">type</span> Mutex <span class="keyword">struct</span>{ ... }
<span class="keyword">type</span> Once <span class="keyword">struct</span>{ ... }
<span class="keyword">type</span> Pool <span class="keyword">struct</span>{ ... }
<span class="keyword">type</span> RWMutex <span class="keyword">struct</span>{ ... }
<span class="keyword">type</span> WaitGroup <span class="keyword">struct</span>{ ... }
</pre><a target="_blank" href="https://pkg.go.dev/sync">pkg.go.dev/sync</a><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li class="current"><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="7"><h2>package context</h2>
<pre><span class="keyword">package</span> context

...

Programs that use Contexts should follow these rules

Do not store Contexts inside a <span class="keyword">struct</span> <span class="keyword">type</span>; instead, pass a Context
explicitly to each function that needs it. The Context should be the
first parameter, typically named ctx:

<span class="keyword">func</span> DoSomething(ctx context.Context, arg Arg) error {
	<span class="comment">// ... use ctx ...</span>
}

Do not pass a nil Context, even if a function permits it. Pass
context.TODO if you are unsure about which Context to use.

Use context Values only for request-scoped data that transits
processes and APIs, not for passing optional parameters to functions.
		</pre><pre>var Canceled = errors.New("context canceled")
var DeadlineExceeded error = deadlineExceededError{}
<span class="keyword">func</span> WithCancel(parent Context) (ctx Context, cancel CancelFunc)
<span class="keyword">func</span> WithDeadline(parent Context, d <span class="type">time.Time</span>) (Context, CancelFunc)
<span class="keyword">func</span> WithTimeout(parent Context, timeout <span class="type">time.Duration</span>) (Context, CancelFunc)
<span class="keyword">type</span> CancelFunc <span class="keyword">func</span>()
<span class="keyword">type</span> Context <span class="keyword">interface</span>{ ... }
    <span class="keyword">func</span> Background() Context
    <span class="keyword">func</span> TODO() Context
    <span class="keyword">func</span> WithValue(parent Context, key, val any) Context
</pre><a target="_blank" href="https://pkg.go.dev/context">pkg.go.dev/context</a><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li class="current"><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="8"><h2>go test -bench</h2>
<div class="srcfile"><pre><code><span class=line><i>  1</i> <span class="keyword">package</span> cotalk</span>
<span class=line><i>  2</i> </span>
<span class=line><i>  3</i> <span class="keyword">import</span> (</span>
<span class=line><i>  4</i>     "fmt"</span>
<span class=line><i>  5</i>     "testing"</span>
<span class=line><i>  6</i>     "time"</span>
<span class=line><i>  7</i> )</span>
<span class=line><i>  8</i> </span>
<span class=line><i>  9</i> <span class="keyword">func</span> BenchmarkX(b *<span class="type">testing.B</span>) {</span>
<span class=line><i> 10</i>     fmt.Println("N is", <span class="type">b.N</span>)</span>
<span class=line><i> 11</i>     <span class="keyword">for</span> i := 0; i < b.N; i++ {</span>
<span class=line><i> 12</i>         X()</span>
<span class=line><i> 13</i>     }</span>
<span class=line><i> 14</i> }</span>
<span class=line><i> 15</i> </span>
<span class=line><i> 16</i> <span class="keyword">func</span> X() {</span>
<span class=line><i> 17</i>     time.Sleep(<span class="type">time.Millisecond</span>)</span>
<span class=line><i> 18</i> }</span>
<span class=line><i> 19</i> </span></code></pre></div>
<pre class="shell dark">$ go test -bench=BenchmarkX -v .<br/>goos: linux
goarch: amd64
pkg: github.com/preferit/cotalk
cpu: Intel(R) Xeon(R) E-2288G CPU @ 3.70GHz
BenchmarkX
N is 1
N is 100
N is 1100
BenchmarkX-16    	    1100	   1095229 ns/op
<span style="color:green;">PASS</span>
ok  	github.com/preferit/cotalk	1.320s
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li class="current"><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="9"><h2>Problem</h2>
<div class="srcfile"><pre><code><span class=line><i>  1</i> <span class="keyword">package</span> cotalk</span>
<span class=line><i>  2</i> </span>
<span class=line><i>  3</i> <span class="keyword">import</span> (</span>
<span class=line><i>  4</i>     "net/http"</span>
<span class=line><i>  5</i> )</span>
<span class=line><i>  6</i> </span>
<span class=line><i>  7</i> <span class="comment">// Problem defines the thing that needs to be solved</span></span>
<span class=line><i>  8</i> <span class="keyword">type</span> Problem <span class="keyword">interface</span> {</span>
<span class=line><i>  9</i> </span>
<span class=line><i> 10</i>     <span class="comment">// Solve returns an error <span class="keyword">if</span> the given algorithm does not solve</span></span>
<span class=line><i> 11</i>     <span class="comment">// the problem.</span></span>
<span class=line><i> 12</i>     Solve(Algorithm) error</span>
<span class=line><i> 13</i> }</span>
<span class=line><i> 14</i> </span>
<span class=line><i> 15</i> <span class="comment">// Algorithm is any <span class="keyword">func</span> that takes some work and returns it's result.</span></span>
<span class=line><i> 16</i> <span class="comment">// The validity of the result must be verified outside.</span></span>
<span class=line><i> 17</i> <span class="keyword">type</span> Algorithm <span class="keyword">func</span>(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>)</span>
<span class=line><i> 18</i> </span></code></pre></div>
<nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li class="current"><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="10"><h2>Letters challenge</h2>
<p>A set of letters <code>0 1 2 3 4 5 6 7 8 9 a b c d e f</code> are available on a server; the problem is to GET them
			and assemble them in the correct order. Each letter is
			found on /L, ie. GET /3 would return '3'.</p>
<div class="srcfile"><pre><code><span class="comment">// NewOrderedLetters returns a problem defined as</span>
<span class="comment">//</span>
<span class="comment">//   - get all letters using a list of requests</span>
<span class="comment">//   - in the given order</span>
<span class="comment">//</span>
<span class="comment">// letters should be a space separated string of letters</span>
<span class="keyword">func</span> NewOrderedLetters(letters string) *OrderedLetters {
    <span class="keyword">return</span> &OrderedLetters{
        exp: letters,
    }
}</code></pre></div>
<nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li class="current"><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="11"><h2>Verification</h2>
<p>Each algorithm in these examples is tested like this</p>
<div class="srcfile"><pre><code><span class="keyword">func</span> BenchmarkAlg01(b *<span class="type">testing.B</span>) {
    problem := NewOrderedLetters(Letters)
    srv := problem.Server()
    <span class="keyword">defer</span> srv.Close()
    <span class="keyword">for</span> i := 0; i < b.N; i++ {
        <span class="keyword">if</span> err := problem.Solve(Alg01); err != nil {
            b.Fatal(err)
        }
    }
}</code></pre></div>
<p>The problem and it's verification method Solve is found
in <a href="https://github.com/preferit/cotalk/blob/main/problem.go">problem.go</a></p>
<nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li class="current"><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="12"><h2>Sequential</h2>
<p>Simple implementation though very low performance</p>
<div class="srcfile"><pre><code><span class=line><i>  9</i> <span class="comment">// Alg01 solves the work sequentially</span></span>
<span class=line><i> 10</i> <span class="keyword">func</span> Alg01(work []*<span class="type">http.Request</span>) []*http.Response {</span>
<span class=line><i> 11</i>     result := make([]*http.Response, 0, len(work))</span>
<span class=line><i> 12</i>     <span class="keyword">for</span> _, r := <span class="keyword">range</span> work {</span>
<span class=line><i> 13</i>         resp, err := http.DefaultClient.Do(r)</span>
<span class=line><i> 14</i>         <span class="keyword">if</span> err != nil {</span>
<span class=line><i> 15</i>             panic(err.Error())</span>
<span class=line><i> 16</i>         }</span>
<span class=line><i> 17</i>         result = append(result, resp)</span>
<span class=line><i> 18</i>     }</span>
<span class=line><i> 19</i>     <span class="keyword">return</span> result</span>
<span class=line><i> 20</i> }</span>
<span class=line><i> 21</i> </span></code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg01 .<br/>goos: linux
goarch: amd64
pkg: github.com/preferit/cotalk
cpu: Intel(R) Xeon(R) E-2288G CPU @ 3.70GHz
BenchmarkAlg01-16    	       6	 175723081 ns/op	  276461 B/op	    1978 allocs/op
<span style="color:green;">PASS</span>
ok  	github.com/preferit/cotalk	1.238s
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li class="current"><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="13"><h2>Concurrent using sync.WaitGroup</h2>
<div class="srcfile"><pre><code><span class=line><i> 22</i> <span class="comment">// Alg02 uses sync.WaitGroup to wait <span class="keyword">for</span> all responses</span></span>
<span class=line><i> 23</i> <span class="keyword">func</span> Alg02(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {</span>
<span class=line><i> 24</i>     <span class="keyword">var</span> wg <span class="type">sync.WaitGroup</span></span>
<span class=line><i> 25</i>     <span class="keyword">for</span> _, r := <span class="keyword">range</span> work {</span>
<span class=line><i> 26</i>         wg.Add(1)</span>
<span class=line><i> 27</i>         <span class="keyword">go</span> <span class="keyword">func</span>() {</span>
<span class=line><i> 28</i>             resp, _ := http.DefaultClient.Do(r)</span>
<span class=line><i> 29</i>             result = append(result, resp)</span>
<span class=line><i> 30</i>             wg.Done()</span>
<span class=line><i> 31</i>         }()</span>
<span class=line><i> 32</i>     }</span>
<span class=line><i> 33</i>     wg.Wait()</span>
<span class=line><i> 34</i>     <span class="keyword">return</span></span>
<span class=line><i> 35</i> }</span>
<span class=line><i> 36</i> </span></code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg02 .<br/><span style="color:red;">--- FAIL:</span> BenchmarkAlg02
    alg_test.go:22: 
        exp: 0 1 2 3 4 5 6 7 8 9 a b c d e f
        got: f f f f f f f f f f f f f f f f
<span style="color:red;">FAIL</span>
exit status 1
<span style="color:red;">FAIL</span>	github.com/preferit/cotalk	0.013s
<span style="color:red;">FAIL</span>
</pre><p>Why does it fail?</p>
<nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li class="current"><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="14"><h2>Arguments are evaluated at calltime</h2>
<div class="srcfile"><pre><code><span class=line><i> 37</i> <span class="comment">// Alg03 fixes reference problem inside loop</span></span>
<span class=line><i> 38</i> <span class="keyword">func</span> Alg03(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {</span>
<span class=line><i> 39</i>     <span class="keyword">var</span> wg <span class="type">sync.WaitGroup</span></span>
<span class=line><i> 40</i>     <span class="keyword">for</span> _, r := <span class="keyword">range</span> work {</span>
<span class=line><i> 41</i>         wg.Add(1)</span>
<span class=line><i> 42</i>         <span class="keyword">go</span> <span class="keyword">func</span>(lr *<span class="type">http.Request</span>) {</span>
<span class=line><i> 43</i>             <span class="comment">// use local argument</span></span>
<span class=line><i> 44</i>             resp, _ := http.DefaultClient.Do(lr)</span>
<span class=line><i> 45</i>             result = append(result, resp)</span>
<span class=line><i> 46</i>             wg.Done()</span>
<span class=line><i> 47</i>         }(r) <span class="comment">// make a copy of pointer with argument</span></span>
<span class=line><i> 48</i>     }</span>
<span class=line><i> 49</i>     wg.Wait()</span>
<span class=line><i> 50</i>     <span class="keyword">return</span></span>
<span class=line><i> 51</i> }</span>
<span class=line><i> 52</i> </span></code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg03 .<br/><span style="color:red;">--- FAIL:</span> BenchmarkAlg03
    alg_test.go:32: 
        exp: 0 1 2 3 4 5 6 7 8 9 a b c d e f
        got: 1 0 5 8 6 2 e 7 d f b 4 c 9 3
<span style="color:red;">FAIL</span>
exit status 1
<span style="color:red;">FAIL</span>	github.com/preferit/cotalk	0.014s
<span style="color:red;">FAIL</span>
</pre><p>You might get a different result; why does it still fail? and can the tooling help identify the problem, try <pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg3 -race -count 1</pre></p>
<nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li class="current"><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="15"><h2>Protect concurrent writes with sync.Mutex</h2>
<div class="srcfile"><pre><code><span class=line><i> 53</i> <span class="comment">// Alg04 synchronizes writes accross <span class="keyword">go</span> routines</span></span>
<span class=line><i> 54</i> <span class="keyword">func</span> Alg04(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {</span>
<span class=line><i> 55</i>     <span class="keyword">var</span> wg <span class="type">sync.WaitGroup</span></span>
<span class=line><i> 56</i>     <span class="keyword">var</span> m <span class="type">sync.Mutex</span></span>
<span class=line><i> 57</i>     <span class="keyword">for</span> _, r := <span class="keyword">range</span> work {</span>
<span class=line><i> 58</i>         wg.Add(1)</span>
<span class=line><i> 59</i>         <span class="keyword">go</span> <span class="keyword">func</span>(lr *<span class="type">http.Request</span>) {</span>
<span class=line><i> 60</i>             resp, _ := http.DefaultClient.Do(lr)</span>
<span class=line><i> 61</i>             <span class="comment">// protect result</span></span>
<span class=line><i> 62</i>             m.Lock()</span>
<span class=line><i> 63</i>             result = append(result, resp)</span>
<span class=line><i> 64</i>             m.Unlock()</span>
<span class=line><i> 65</i>             wg.Done()</span>
<span class=line><i> 66</i>         }(r)</span>
<span class=line><i> 67</i>     }</span>
<span class=line><i> 68</i>     wg.Wait()</span>
<span class=line><i> 69</i>     <span class="keyword">return</span></span>
<span class=line><i> 70</i> }</span>
<span class=line><i> 71</i> </span></code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg04 .<br/><span style="color:red;">--- FAIL:</span> BenchmarkAlg04
    alg_test.go:42: 
        exp: 0 1 2 3 4 5 6 7 8 9 a b c d e f
        got: d 1 c 5 4 3 8 7 e 2 a 9 f 6 b 0
<span style="color:red;">FAIL</span>
exit status 1
<span style="color:red;">FAIL</span>	github.com/preferit/cotalk	0.014s
<span style="color:red;">FAIL</span>
</pre><p>Why does it fail?</p>
<nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li class="current"><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="16"><h2>Sort results</h2>
<div class="srcfile"><pre><code><span class=line><i> 72</i> <span class="comment">// Alg05 fix order</span></span>
<span class=line><i> 73</i> <span class="keyword">func</span> Alg05(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {</span>
<span class=line><i> 74</i>     <span class="keyword">var</span> wg <span class="type">sync.WaitGroup</span></span>
<span class=line><i> 75</i>     <span class="keyword">var</span> m <span class="type">sync.Mutex</span></span>
<span class=line><i> 76</i>     result = make([]*http.Response, len(work))</span>
<span class=line><i> 77</i>     <span class="keyword">for</span> i, r := <span class="keyword">range</span> work {</span>
<span class=line><i> 78</i>         wg.Add(1)</span>
<span class=line><i> 79</i>         <span class="keyword">go</span> <span class="keyword">func</span>(i int, lr *<span class="type">http.Request</span>) {</span>
<span class=line><i> 80</i>             resp, _ := http.DefaultClient.Do(lr)</span>
<span class=line><i> 81</i>             <span class="comment">// protect result</span></span>
<span class=line><i> 82</i>             m.Lock()</span>
<span class=line><i> 83</i>             result[i] = resp</span>
<span class=line><i> 84</i>             m.Unlock()</span>
<span class=line><i> 85</i>             wg.Done()</span>
<span class=line><i> 86</i>         }(i, r)</span>
<span class=line><i> 87</i>     }</span>
<span class=line><i> 88</i>     wg.Wait()</span>
<span class=line><i> 89</i>     <span class="keyword">return</span></span>
<span class=line><i> 90</i> }</span>
<span class=line><i> 91</i> </span></code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg05 .<br/>goos: linux
goarch: amd64
pkg: github.com/preferit/cotalk
cpu: Intel(R) Xeon(R) E-2288G CPU @ 3.70GHz
BenchmarkAlg05-16    	     100	  13281838 ns/op	  289424 B/op	    2018 allocs/op
<span style="color:green;">PASS</span>
ok  	github.com/preferit/cotalk	1.344s
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li class="current"><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="17"><h2>Improved performance paid with complexity</h2>
<p>Comparing the sequential working algorithm to the working
		concurrent one, tests reveal a substantial improvement.</p>
<pre class="shell dark">$ go test -benchmem -bench="(Alg1|Alg5)$"<br/>goos: linux
goarch: amd64
pkg: github.com/preferit/cotalk
cpu: Intel(R) Xeon(R) E-2288G CPU @ 3.70GHz
BenchmarkAlg1-16    	       6	 175609134 ns/op	  276349 B/op	    1976 allocs/op
BenchmarkAlg5-16    	      87	  13308022 ns/op	  292652 B/op	    2021 allocs/op
<span style="color:green;">PASS</span>
ok  	github.com/preferit/cotalk	2.413s
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li class="current"><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="18"><h2>Using channel</h2>
<div class="srcfile"><pre><code><span class=line><i> 92</i> <span class="comment">// Alg06 uses channel to synchronize responses</span></span>
<span class=line><i> 93</i> <span class="keyword">func</span> Alg06(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {</span>
<span class=line><i> 94</i>     c := make(chan *<span class="type">http.Response</span>)</span>
<span class=line><i> 95</i>     <span class="keyword">for</span> _, r := <span class="keyword">range</span> work {</span>
<span class=line><i> 96</i>         <span class="keyword">go</span> <span class="keyword">func</span>(lr *<span class="type">http.Request</span>) {</span>
<span class=line><i> 97</i>             resp, _ := http.DefaultClient.Do(lr)</span>
<span class=line><i> 98</i>             c <- resp <span class="comment">// write to channel</span></span>
<span class=line><i> 99</i>         }(r)</span>
<span class=line><i>100</i>     }</span>
<span class=line><i>101</i>     <span class="keyword">for</span> <span class="keyword">range</span> work {</span>
<span class=line><i>102</i>         resp := <-c <span class="comment">// read from channel</span></span>
<span class=line><i>103</i>         result = append(result, resp)</span>
<span class=line><i>104</i>     }</span>
<span class=line><i>105</i>     <span class="keyword">return</span></span>
<span class=line><i>106</i> }</span>
<span class=line><i>107</i> </span></code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg06 .<br/><span style="color:red;">--- FAIL:</span> BenchmarkAlg06
    alg_test.go:62: 
        exp: 0 1 2 3 4 5 6 7 8 9 a b c d e f
        got: f c b 9 d a 0 3 4 2 5 7 e 1 6 8
<span style="color:red;">FAIL</span>
exit status 1
<span style="color:red;">FAIL</span>	github.com/preferit/cotalk	0.014s
<span style="color:red;">FAIL</span>
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li class="current"><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="19"><h2>Correct order using channel</h2>
<div class="srcfile"><pre><code><span class=line><i>108</i> <span class="comment">// Alg07 uses channel to synchronize responses with ordered result</span></span>
<span class=line><i>109</i> <span class="keyword">func</span> Alg07(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {</span>
<span class=line><i>110</i>     <span class="keyword">type</span> m <span class="keyword">struct</span> {</span>
<span class=line><i>111</i>         index int</span>
<span class=line><i>112</i>         *<span class="type">http.Response</span></span>
<span class=line><i>113</i>     }</span>
<span class=line><i>114</i>     c := make(chan m)</span>
<span class=line><i>115</i>     result = make([]*http.Response, len(work))</span>
<span class=line><i>116</i>     <span class="keyword">for</span> i, r := <span class="keyword">range</span> work {</span>
<span class=line><i>117</i>         <span class="keyword">go</span> <span class="keyword">func</span>(i int, lr *<span class="type">http.Request</span>) {</span>
<span class=line><i>118</i>             resp, _ := http.DefaultClient.Do(lr)</span>
<span class=line><i>119</i>             c <- m{i, resp} <span class="comment">// write to channel</span></span>
<span class=line><i>120</i>         }(i, r)</span>
<span class=line><i>121</i>     }</span>
<span class=line><i>122</i>     <span class="keyword">for</span> <span class="keyword">range</span> work {</span>
<span class=line><i>123</i>         v := <-c <span class="comment">// read from channel</span></span>
<span class=line><i>124</i>         result[v.index] = <span class="type">v.Response</span></span>
<span class=line><i>125</i>     }</span>
<span class=line><i>126</i>     <span class="keyword">return</span></span>
<span class=line><i>127</i> }</span>
<span class=line><i>128</i> </span></code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg07 .<br/>goos: linux
goarch: amd64
pkg: github.com/preferit/cotalk
cpu: Intel(R) Xeon(R) E-2288G CPU @ 3.70GHz
BenchmarkAlg07-16    	     100	  13411328 ns/op	  293160 B/op	    2025 allocs/op
<span style="color:green;">PASS</span>
ok  	github.com/preferit/cotalk	1.357s
</pre><p>There is still a bug in this code, do you see it?</p>
<nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li class="current"><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="20"><h2>Clean up resources</h2>
<div class="srcfile"><pre><code><span class=line><i>129</i> <span class="comment">// Alg08 uses channel to synchronize responses with ordered result</span></span>
<span class=line><i>130</i> <span class="keyword">func</span> Alg08(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {</span>
<span class=line><i>131</i>     <span class="keyword">type</span> m <span class="keyword">struct</span> {</span>
<span class=line><i>132</i>         index int</span>
<span class=line><i>133</i>         *<span class="type">http.Response</span></span>
<span class=line><i>134</i>     }</span>
<span class=line><i>135</i>     c := make(chan m)</span>
<span class=line><i>136</i>     <span class="keyword">defer</span> close(c) <span class="comment">// make sure you clean up when done</span></span>
<span class=line><i>137</i>     result = make([]*http.Response, len(work))</span>
<span class=line><i>138</i>     <span class="keyword">for</span> i, r := <span class="keyword">range</span> work {</span>
<span class=line><i>139</i>         <span class="keyword">go</span> <span class="keyword">func</span>(i int, lr *<span class="type">http.Request</span>) {</span>
<span class=line><i>140</i>             resp, _ := http.DefaultClient.Do(lr)</span>
<span class=line><i>141</i>             c <- m{i, resp} <span class="comment">// write to channel</span></span>
<span class=line><i>142</i>         }(i, r)</span>
<span class=line><i>143</i>     }</span>
<span class=line><i>144</i>     <span class="keyword">for</span> <span class="keyword">range</span> work {</span>
<span class=line><i>145</i>         v := <-c <span class="comment">// read from channel</span></span>
<span class=line><i>146</i>         result[v.index] = <span class="type">v.Response</span></span>
<span class=line><i>147</i>     }</span>
<span class=line><i>148</i>     <span class="keyword">return</span></span>
<span class=line><i>149</i> }</span>
<span class=line><i>150</i> </span></code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg08 .<br/>goos: linux
goarch: amd64
pkg: github.com/preferit/cotalk
cpu: Intel(R) Xeon(R) E-2288G CPU @ 3.70GHz
BenchmarkAlg08-16    	      99	  13400211 ns/op	  292396 B/op	    2022 allocs/op
<span style="color:green;">PASS</span>
ok  	github.com/preferit/cotalk	1.356s
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li class="current"><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="21"><h2>Interrupt</h2>
<div class="srcfile"><pre><code><span class=line><i>151</i> <span class="comment">// Alg09 returns when all work is done or context is cancelled</span></span>
<span class=line><i>152</i> <span class="keyword">func</span> Alg09(ctx context.Context, work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {</span>
<span class=line><i>153</i>     <span class="keyword">type</span> m <span class="keyword">struct</span> {</span>
<span class=line><i>154</i>         index int</span>
<span class=line><i>155</i>         *<span class="type">http.Response</span></span>
<span class=line><i>156</i>     }</span>
<span class=line><i>157</i>     c := make(chan m)</span>
<span class=line><i>158</i>     complete := make(chan <span class="keyword">struct</span>{})</span>
<span class=line><i>159</i>     <span class="keyword">defer</span> close(c) <span class="comment">// make sure you clean up when done</span></span>
<span class=line><i>160</i>     result = make([]*http.Response, len(work))</span>
<span class=line><i>161</i>     <span class="keyword">go</span> <span class="keyword">func</span>() {</span>
<span class=line><i>162</i>         <span class="keyword">defer</span> close(complete)</span>
<span class=line><i>163</i>         <span class="keyword">for</span> i, r := <span class="keyword">range</span> work {</span>
<span class=line><i>164</i>             <span class="keyword">go</span> <span class="keyword">func</span>(i int, lr *<span class="type">http.Request</span>) {</span>
<span class=line><i>165</i>                 resp, _ := http.DefaultClient.Do(lr)</span>
<span class=line><i>166</i>                 c <- m{i, resp} <span class="comment">// write to channel</span></span>
<span class=line><i>167</i>             }(i, r)</span>
<span class=line><i>168</i>         }</span>
<span class=line><i>169</i>         <span class="keyword">for</span> <span class="keyword">range</span> work {</span>
<span class=line><i>170</i>             v := <-c <span class="comment">// read from channel</span></span>
<span class=line><i>171</i>             result[v.index] = <span class="type">v.Response</span></span>
<span class=line><i>172</i>         }</span>
<span class=line><i>173</i>     }()</span>
<span class=line><i>174</i>     <span class="keyword">select</span> {</span>
<span class=line><i>175</i>     <span class="keyword">case</span> <-ctx.Done():</span>
<span class=line><i>176</i>         <span class="comment">// interrupted</span></span>
<span class=line><i>177</i>     <span class="keyword">case</span> <-complete:</span>
<span class=line><i>178</i>     }</span>
<span class=line><i>179</i>     <span class="keyword">return</span></span>
<span class=line><i>180</i> }</span>
<span class=line><i>181</i> </span></code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg09 .<br/>goos: linux
goarch: amd64
pkg: github.com/preferit/cotalk
cpu: Intel(R) Xeon(R) E-2288G CPU @ 3.70GHz
BenchmarkAlg09-16    	panic: <span style="color:red;">send on closed channel</span>

goroutine 499 [running]:
github.com/preferit/cotalk.Alg9.func1.1(0x3, 0xc00040a780?)
	/home/gregory/src/github.com/preferit/cotalk/alg.go:162 +0x55
created by github.com/preferit/cotalk.Alg9.func1
	/home/gregory/src/github.com/preferit/cotalk/alg.go:160 +0x8e
exit status 2
<span style="color:red;">FAIL</span>	github.com/preferit/cotalk	0.054s
<span style="color:red;">FAIL</span>
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li class="current"><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="22"><h2>Respect context cancellation</h2>
<div class="srcfile"><pre><code><span class=line><i>182</i> <span class="comment">// Alg10 returns when all work is done or context is cancelled</span></span>
<span class=line><i>183</i> <span class="keyword">func</span> Alg10(ctx context.Context, work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {</span>
<span class=line><i>184</i>     <span class="keyword">type</span> m <span class="keyword">struct</span> {</span>
<span class=line><i>185</i>         index int</span>
<span class=line><i>186</i>         *<span class="type">http.Response</span></span>
<span class=line><i>187</i>     }</span>
<span class=line><i>188</i>     c := make(chan m)</span>
<span class=line><i>189</i>     complete := make(chan <span class="keyword">struct</span>{})</span>
<span class=line><i>190</i>     <span class="keyword">defer</span> close(c) <span class="comment">// make sure you clean up when done</span></span>
<span class=line><i>191</i>     result = make([]*http.Response, len(work))</span>
<span class=line><i>192</i>     <span class="keyword">go</span> <span class="keyword">func</span>() {</span>
<span class=line><i>193</i>         <span class="keyword">defer</span> close(complete)</span>
<span class=line><i>194</i>         <span class="keyword">for</span> i, r := <span class="keyword">range</span> work {</span>
<span class=line><i>195</i>             <span class="keyword">go</span> <span class="keyword">func</span>(i int, lr *<span class="type">http.Request</span>) {</span>
<span class=line><i>196</i>                 resp, _ := http.DefaultClient.Do(lr)</span>
<span class=line><i>197</i>                 <span class="keyword">select</span> {</span>
<span class=line><i>198</i>                 <span class="keyword">case</span> <-ctx.Done():</span>
<span class=line><i>199</i>                 default:</span>
<span class=line><i>200</i>                     c <- m{i, resp} <span class="comment">// write to channel</span></span>
<span class=line><i>201</i>                 }</span>
<span class=line><i>202</i>             }(i, r)</span>
<span class=line><i>203</i>         }</span>
<span class=line><i>204</i>         <span class="keyword">for</span> <span class="keyword">range</span> work {</span>
<span class=line><i>205</i>             v := <-c <span class="comment">// read from channel</span></span>
<span class=line><i>206</i>             result[v.index] = <span class="type">v.Response</span></span>
<span class=line><i>207</i>         }</span>
<span class=line><i>208</i>     }()</span>
<span class=line><i>209</i>     <span class="keyword">select</span> {</span>
<span class=line><i>210</i>     <span class="keyword">case</span> <-ctx.Done():</span>
<span class=line><i>211</i>         <span class="comment">// interrupted</span></span>
<span class=line><i>212</i>     <span class="keyword">case</span> <-complete:</span>
<span class=line><i>213</i>     }</span>
<span class=line><i>214</i>     <span class="keyword">return</span></span>
<span class=line><i>215</i> }</span>
<span class=line><i>216</i> </span></code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg10 .<br/>goos: linux
goarch: amd64
pkg: github.com/preferit/cotalk
cpu: Intel(R) Xeon(R) E-2288G CPU @ 3.70GHz
<span style="color:red;">BenchmarkAlg10-16    	--- FAIL:</span> BenchmarkAlg10-16
    alg_test.go:123: 
        exp: 0 1 2 3 4 5 6 7 8 9 a b c d e f
        got: 0             7       b       f
<span style="color:red;">FAIL</span>
exit status 1
<span style="color:red;">FAIL</span>	github.com/preferit/cotalk	0.074s
<span style="color:red;">FAIL</span>
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li class="current"><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="23"><h2>Compare all</h2>
<p>In this example using channels and sync package primitives
		seem to yield more or less the same result. There performance
		boost would be to try and minimize number of allocations. But
		that is out of scope of this talk.</p>
<pre class="shell dark">$ go test -benchmem -bench="(Alg1|Alg5|Alg8)$"<br/>goos: linux
goarch: amd64
pkg: github.com/preferit/cotalk
cpu: Intel(R) Xeon(R) E-2288G CPU @ 3.70GHz
BenchmarkAlg1-16    	       6	 175310048 ns/op	  277350 B/op	    1982 allocs/op
BenchmarkAlg5-16    	      88	  13202327 ns/op	  293016 B/op	    2026 allocs/op
BenchmarkAlg8-16    	      91	  13449404 ns/op	  289586 B/op	    2019 allocs/op
<span style="color:green;">PASS</span>
ok  	github.com/preferit/cotalk	3.652s
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li class="current"><a href="#23">23</a></li>
<li><a href="#24">24</a></li>
</ul>
</nav>
</div>
<div class="slide" id="24"><h2>Go concurrency design summary</h2>
<ul>
<li>concurrency is difficult to get right; even in Go</li>
<li>tests are an invaluable tool when debugging concurrency issues</li>
<li>never assume performance optimizations, always measure</li>
<li>if performance is good enough with a sequential algorithm, skip the complexity of concurrency</li>
</ul>
<nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li> | </li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li> | </li>
<li><a href="#17">17</a></li>
<li><a href="#18">18</a></li>
<li><a href="#19">19</a></li>
<li><a href="#20">20</a></li>
<li><a href="#21">21</a></li>
<li><a href="#22">22</a></li>
<li><a href="#23">23</a></li>
<li class="current"><a href="#24">24</a></li>
</ul>
</nav>
</div>
<script>function enhance() {
    // if there is no hash, start with the first slide
    var hash = window.location.hash;
    if (hash == "") {
	window.location += "#1"
	return
    }

    // handle clicks on slide changes
    window.onhashchange = toggleSlide;

    hash = hash.substring(1) // ignore the #
    var slides = document.getElementsByClassName("slide");
    for (var i = 0; i < slides.length; i++) {
	var s = slides.item(i);

	// hide all but the hashed one	
	if (s.id != hash) {
	    s.style.display = 'none';
	} else {
	    s.style.diplay = 'block';
	}
    }
}

var currentHash = window.location.hash;

function toggleSlide() {
    var c = document.getElementById(currentHash.substring(1));
    c.style.display = 'none';
    var n = document.getElementById(window.location.hash.substring(1))
    n.style.display = 'block';
    currentHash = window.location.hash;
}



enhance()
</script>
</body>
</html>
