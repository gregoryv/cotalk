<!DOCTYPE html>

<html>
<head>
<title>Go concurrency</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>html, body {
margin: 0 0;
padding: 0 0;
}
.slide {
font-size: 150%;
padding: 10px 20%;
text-align: center;
height: calc( 100vh - 50px);
}
p, pre {
text-align: left;
}
nav {
text-align: center;
}
nav ul {
list-style-type: none;
margin: 0 0;
padding: 0 0;
}
nav ul li {
margin: 0 4px;
cursor: pointer;
display: inline;
}
nav ul li.current {
text-decoration: underline;
}
a:link, a:visited {
color: #007d9c;
text-decoration: none;
}
a:hover {
text-decoration: underline;
}
.header {
width: 100%;
border-bottom: 1px solid #727272;
text-align: right;
margin-top: -2em;
margin-bottom: 1em;
}
h1, h2, h3 {
text-align: center;
}
.srcfile {
margin-top: 1.6em;
margin-bottom: 1.6em;
background-image: url("printout-whole.png");
background-repeat: repeat-y;
padding-left: 36px;
background-color: #fafafa;
tab-size: 4;
-moz-tab-size: 4;
}
.filename {
float: left;
margin-right: 1.6em;
margin-top: -1.6em;
}
.srcfile code {
padding: .6em 0 .6em 0;
background-image: url("printout-whole.png");
background-repeat: repeat-y;
background-position: right top;
display: block;
text-align: left;
}
nav {
margin-top: 1em;
text-align: center;
}
nav a:link, nav a:visited {
color: #727272;
padding: 0 5px;
margin: 0 2px;
text-decoration: none;
}
nav a.current, nav a:hover {
color: black;
border-bottom: 1px solid black;
}
li.h3 {
margin-left: 2em;
}
.shell {
padding: 1em;
border-radius: 10px;
}
.dark {
background-color: #2e2e34;
color: aliceblue;
}
.light {
background-color: #ffffff;
color: #3b2616;
}
img.center {
display: block;
margin-left: auto;
margin-right: auto;
}
img.left {
float: left;
margin-right: 2em;
}
.group {
float: left;
text-align: left;
margin-right: 3em;
}
.keyword {
color: darkviolet;
}
.type {
color: dodgerblue;
}
.comment, .comment>span {
color: darkgreen;
}
</style>
</head>
<body>
<div class="slide" id="1"><a href="#2"><img src="cotalk.png"/></a><span>2023 by Gregory Vinčić</span></div>
<div class="slide" id="2"><h1>Content</h1>
<p>Discussion and examples of using concepts related to
		concurrent design.<ul class="group">
<li>background and history</li>
<li>goroutines</li>
<li>channels</li>
</ul>
<ul class="group">
<li>package context</li>
<li>package sync </li>
<li>go test bench</li>
</ul>
<ul class="group">
<li>examples and training</li>
</ul>
</p>
<br clear="all"/><nav><ul>
<li><a href="#1">1</a></li>
<li class="current"><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li> | </li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
</ul>
</nav>
</div>
<div class="slide" id="3"><h2>Background and history</h2>
<img class="left" src="th_small.jpg"/><br/><a href="http://www.usingcsp.com/cspbook.pdf">Communicating Sequential Processes</a> C. A. R. Hoare, 1985<br clear="all"/><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li class="current"><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li> | </li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
</ul>
</nav>
</div>
<div class="slide" id="4"><h2>Goroutines</h2>
<a target="_blank" href="https://go.dev/tour/concurrency/1"><img class="center" src="gotour_concurrency_1.png"/></a><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li class="current"><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li> | </li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
</ul>
</nav>
</div>
<div class="slide" id="5"><h2>channels</h2>
<a target="_blank" href="https://go.dev/tour/concurrency/2"><img class="center" src="gotour_concurrency_2.png"/></a><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li class="current"><a href="#5">5</a></li>
<li> | </li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
</ul>
</nav>
</div>
<div class="slide" id="6"><h2>package sync</h2>
<div class="srcfile"><pre><code><span class="keyword">type</span> Cond <span class="keyword">struct</span>{ ... }
    <span class="keyword">func</span> NewCond(l Locker) *Cond
<span class="keyword">type</span> Locker <span class="keyword">interface</span>{ ... }
<span class="keyword">type</span> Map <span class="keyword">struct</span>{ ... }
<span class="keyword">type</span> Mutex <span class="keyword">struct</span>{ ... }
<span class="keyword">type</span> Once <span class="keyword">struct</span>{ ... }
<span class="keyword">type</span> Pool <span class="keyword">struct</span>{ ... }
<span class="keyword">type</span> RWMutex <span class="keyword">struct</span>{ ... }
<span class="keyword">type</span> WaitGroup <span class="keyword">struct</span>{ ... }
</code></pre></div>
<a target="_blank" href="https://pkg.go.dev/sync">pkg.go.dev/sync</a><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li> | </li>
<li class="current"><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
</ul>
</nav>
</div>
<div class="slide" id="7"><h2>package context</h2>
<pre>
Programs that use Contexts should follow these rules

Do not store Contexts inside a <span class="keyword">struct</span> <span class="keyword">type</span>; instead, pass a Context
explicitly to each function that needs it. The Context should be the
first parameter, typically named ctx:

<span class="keyword">func</span> DoSomething(ctx context.Context, arg Arg) error {
	<span class="comment">// ... use ctx ...</span>
}

Do not pass a nil Context, even if a function permits it. Pass
context.TODO if you are unsure about which Context to use.

Use context Values only for request-scoped data that transits
processes and APIs, not for passing optional parameters to functions.
		</pre><div class="srcfile"><pre><code>var Canceled = errors.New("context canceled")
var DeadlineExceeded error = deadlineExceededError{}
<span class="keyword">func</span> WithCancel(parent Context) (ctx Context, cancel CancelFunc)
<span class="keyword">func</span> WithDeadline(parent Context, d <span class="type">time.Time</span>) (Context, CancelFunc)
<span class="keyword">func</span> WithTimeout(parent Context, timeout <span class="type">time.Duration</span>) (Context, CancelFunc)
<span class="keyword">type</span> CancelFunc <span class="keyword">func</span>()
<span class="keyword">type</span> Context <span class="keyword">interface</span>{ ... }
    <span class="keyword">func</span> Background() Context
    <span class="keyword">func</span> TODO() Context
    <span class="keyword">func</span> WithValue(parent Context, key, val any) Context
</code></pre></div>
<a target="_blank" href="https://pkg.go.dev/context">pkg.go.dev/context</a><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li> | </li>
<li><a href="#6">6</a></li>
<li class="current"><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
</ul>
</nav>
</div>
<div class="slide" id="8"><h2>go test -bench</h2>
<div class="srcfile"><pre><code><span class="keyword">package</span> cotalk

<span class="keyword">import</span> (
    "testing"
    "time"
)

<span class="keyword">func</span> BenchmarkX(b *<span class="type">testing.B</span>) {
    <span class="keyword">for</span> i := 0; i < b.N; i++ {
        X()
    }
}

<span class="keyword">func</span> X() {
    time.Sleep(<span class="type">time.Millisecond</span>)
}
</code></pre></div>
<nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li> | </li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li class="current"><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
</ul>
</nav>
</div>
<div class="slide" id="9"><h2>Problem</h2>
<p>A set of letters <code>0 1 2 3 4 5 6 7 8 9 a b c d e f</code> are available on a server; the problem is to GET them
			and assemble them in the correct order. Each letter is
			found on /L, ie. GET /3 would return '3'.</p>
<p>To simplify the examples we define the Algorithm that does the work as<pre><code><span class="keyword">type</span> Algorithm <span class="keyword">func</span>(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>)</code></pre></p>
<nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li> | </li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li class="current"><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
</ul>
</nav>
</div>
<div class="slide" id="10"><h2>Sequential</h2>
<p>Simple implementation though very low performance</p>
<div class="srcfile"><pre><code><span class="comment">// Alg1 solves the work sequentially</span>
<span class="keyword">func</span> Alg1(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {
    <span class="keyword">for</span> _, r := <span class="keyword">range</span> work {
        resp, _ := http.DefaultClient.Do(r)
        result = append(result, resp)
    }
    <span class="keyword">return</span>
}
</code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg1 .<br/>goos: linux
goarch: amd64
pkg: github.com/preferit/cotalk
cpu: Intel(R) Xeon(R) E-2288G CPU @ 3.70GHz
BenchmarkAlg1-16    	       6	 175723081 ns/op	  276461 B/op	    1978 allocs/op
<span style="color:green;">PASS</span>
ok  	github.com/preferit/cotalk	1.238s
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li> | </li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li class="current"><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
</ul>
</nav>
</div>
<div class="slide" id="11"><h2>Concurrent</h2>
<p>This algorithm uses the sync.WaitGroup to wait for all requests to complete; however it has several bugs.</p>
<div class="srcfile"><pre><code><span class="comment">// Alg2 uses sync.WaitGroup to wait <span class="keyword">for</span> all responses</span>
<span class="keyword">func</span> Alg2(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {
    <span class="keyword">var</span> wg <span class="type">sync.WaitGroup</span>
    <span class="keyword">for</span> _, r := <span class="keyword">range</span> work {
        wg.Add(1)
        <span class="keyword">go</span> <span class="keyword">func</span>() {
            resp, _ := http.DefaultClient.Do(r)
            result = append(result, resp)
            wg.Done()
        }()
    }
    wg.Wait()
    <span class="keyword">return</span>
}
</code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg2 .<br/><span style="color:red;">--- FAIL:</span> BenchmarkAlg2
    alg_test.go:22: 
        exp: 0 1 2 3 4 5 6 7 8 9 a b c d e f
        got: f f f f f f f f f f f f f f f f
<span style="color:red;">FAIL</span>
exit status 1
<span style="color:red;">FAIL</span>	github.com/preferit/cotalk	0.013s
<span style="color:red;">FAIL</span>
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li> | </li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li class="current"><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
</ul>
</nav>
</div>
<div class="slide" id="12"><h2>Concurrent</h2>
<p>Bug 1; you cannot assume go routines start immediately.</p>
<div class="srcfile"><pre><code><span class="comment">// Alg3 fixes reference problem inside loop</span>
<span class="keyword">func</span> Alg3(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {
    <span class="keyword">var</span> wg <span class="type">sync.WaitGroup</span>
    <span class="keyword">for</span> _, r := <span class="keyword">range</span> work {
        wg.Add(1)
        <span class="keyword">go</span> <span class="keyword">func</span>(lr *<span class="type">http.Request</span>) {
            <span class="comment">// use local argument</span>
            resp, _ := http.DefaultClient.Do(lr)
            result = append(result, resp)
            wg.Done()
        }(r) <span class="comment">// make a copy of pointer with argument</span>
    }
    wg.Wait()
    <span class="keyword">return</span>
}
</code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg3 .<br/><span style="color:red;">--- FAIL:</span> BenchmarkAlg3
    alg_test.go:32: 
        exp: 0 1 2 3 4 5 6 7 8 9 a b c d e f
        got: 1 0 5 8 6 2 e 7 d f b 4 c 9 3
<span style="color:red;">FAIL</span>
exit status 1
<span style="color:red;">FAIL</span>	github.com/preferit/cotalk	0.014s
<span style="color:red;">FAIL</span>
</pre><p>You might get a different result; but why does it fail?</p>
<nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li> | </li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li class="current"><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
</ul>
</nav>
</div>
<div class="slide" id="13"><h2>Concurrent</h2>
<p>Bug 2; Unprotected write to slice</p>
<div class="srcfile"><pre><code><span class="comment">// Alg4 synchronizes writes accross <span class="keyword">go</span> routines</span>
<span class="keyword">func</span> Alg4(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {
    <span class="keyword">var</span> wg <span class="type">sync.WaitGroup</span>
    <span class="keyword">var</span> m <span class="type">sync.Mutex</span>
    <span class="keyword">for</span> _, r := <span class="keyword">range</span> work {
        wg.Add(1)
        <span class="keyword">go</span> <span class="keyword">func</span>(lr *<span class="type">http.Request</span>) {
            resp, _ := http.DefaultClient.Do(lr)
            <span class="comment">// protect result</span>
            m.Lock()
            result = append(result, resp)
            m.Unlock()
            wg.Done()
        }(r)
    }
    wg.Wait()
    <span class="keyword">return</span>
}
</code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg4 .<br/><span style="color:red;">--- FAIL:</span> BenchmarkAlg4
    alg_test.go:42: 
        exp: 0 1 2 3 4 5 6 7 8 9 a b c d e f
        got: d 1 c 5 4 3 8 7 e 2 a 9 f 6 b 0
<span style="color:red;">FAIL</span>
exit status 1
<span style="color:red;">FAIL</span>	github.com/preferit/cotalk	0.014s
<span style="color:red;">FAIL</span>
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li> | </li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li class="current"><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
</ul>
</nav>
</div>
<div class="slide" id="14"><h2>Concurrent</h2>
<p>Bug 3; Fix order</p>
<div class="srcfile"><pre><code><span class="comment">// Alg5 fix order</span>
<span class="keyword">func</span> Alg5(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {
    <span class="keyword">var</span> wg <span class="type">sync.WaitGroup</span>
    <span class="keyword">var</span> m <span class="type">sync.Mutex</span>
    result = make([]*http.Response, len(work))
    <span class="keyword">for</span> i, r := <span class="keyword">range</span> work {
        wg.Add(1)
        <span class="keyword">go</span> <span class="keyword">func</span>(i int, lr *<span class="type">http.Request</span>) {
            resp, _ := http.DefaultClient.Do(lr)
            <span class="comment">// protect result</span>
            m.Lock()
            result[i] = resp
            m.Unlock()
            wg.Done()
        }(i, r)
    }
    wg.Wait()
    <span class="keyword">return</span>
}
</code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg5 .<br/>goos: linux
goarch: amd64
pkg: github.com/preferit/cotalk
cpu: Intel(R) Xeon(R) E-2288G CPU @ 3.70GHz
BenchmarkAlg5-16    	     100	  13281838 ns/op	  289424 B/op	    2018 allocs/op
<span style="color:green;">PASS</span>
ok  	github.com/preferit/cotalk	1.344s
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li> | </li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li class="current"><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
</ul>
</nav>
</div>
<div class="slide" id="15"><h2>Concurrent</h2>
<p>Using channels</p>
<div class="srcfile"><pre><code><span class="comment">// Alg6 uses channel to synchronize responses</span>
<span class="keyword">func</span> Alg6(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {
    c := make(chan *<span class="type">http.Response</span>)
    <span class="keyword">for</span> _, r := <span class="keyword">range</span> work {
        <span class="keyword">go</span> <span class="keyword">func</span>(lr *<span class="type">http.Request</span>) {
            resp, _ := http.DefaultClient.Do(lr)
            c <- resp <span class="comment">// write to channel</span>
        }(r)
    }
    <span class="keyword">for</span> <span class="keyword">range</span> work {
        resp := <-c <span class="comment">// read from channel</span>
        result = append(result, resp)
    }
    <span class="keyword">return</span>
}
</code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg6 .<br/><span style="color:red;">--- FAIL:</span> BenchmarkAlg6
    alg_test.go:62: 
        exp: 0 1 2 3 4 5 6 7 8 9 a b c d e f
        got: f c b 9 d a 0 3 4 2 5 7 e 1 6 8
<span style="color:red;">FAIL</span>
exit status 1
<span style="color:red;">FAIL</span>	github.com/preferit/cotalk	0.014s
<span style="color:red;">FAIL</span>
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li> | </li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li class="current"><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
</ul>
</nav>
</div>
<div class="slide" id="16"><h2>Concurrent</h2>
<p>Using channels with correct order</p>
<div class="srcfile"><pre><code><span class="comment">// Alg7 uses channel to synchronize responses with ordered result</span>
<span class="keyword">func</span> Alg7(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {
    <span class="keyword">type</span> m <span class="keyword">struct</span> {
        index int
        *<span class="type">http.Response</span>
    }
    c := make(chan m)
    result = make([]*http.Response, len(work))
    <span class="keyword">for</span> i, r := <span class="keyword">range</span> work {
        <span class="keyword">go</span> <span class="keyword">func</span>(i int, lr *<span class="type">http.Request</span>) {
            resp, _ := http.DefaultClient.Do(lr)
            c <- m{i, resp} <span class="comment">// write to channel</span>
        }(i, r)
    }
    <span class="keyword">for</span> <span class="keyword">range</span> work {
        v := <-c <span class="comment">// read from channel</span>
        result[v.index] = <span class="type">v.Response</span>
    }
    <span class="keyword">return</span>
}
</code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg7 .<br/>goos: linux
goarch: amd64
pkg: github.com/preferit/cotalk
cpu: Intel(R) Xeon(R) E-2288G CPU @ 3.70GHz
BenchmarkAlg7-16    	     100	  13411328 ns/op	  293160 B/op	    2025 allocs/op
<span style="color:green;">PASS</span>
ok  	github.com/preferit/cotalk	1.357s
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li> | </li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li class="current"><a href="#16">16</a></li>
<li><a href="#17">17</a></li>
</ul>
</nav>
<p>There is still a bug in this code, do you see it?</p>
</div>
<div class="slide" id="17"><h2>Concurrent</h2>
<p>Clean up resources</p>
<div class="srcfile"><pre><code><span class="comment">// Alg8 uses channel to synchronize responses with ordered result</span>
<span class="keyword">func</span> Alg8(work []*<span class="type">http.Request</span>) (result []*<span class="type">http.Response</span>) {
    <span class="keyword">type</span> m <span class="keyword">struct</span> {
        index int
        *<span class="type">http.Response</span>
    }
    c := make(chan m)
    <span class="keyword">defer</span> close(c) <span class="comment">// make sure you clean up when done</span>
    result = make([]*http.Response, len(work))
    <span class="keyword">for</span> i, r := <span class="keyword">range</span> work {
        <span class="keyword">go</span> <span class="keyword">func</span>(i int, lr *<span class="type">http.Request</span>) {
            resp, _ := http.DefaultClient.Do(lr)
            c <- m{i, resp} <span class="comment">// write to channel</span>
        }(i, r)
    }
    <span class="keyword">for</span> <span class="keyword">range</span> work {
        v := <-c <span class="comment">// read from channel</span>
        result[v.index] = <span class="type">v.Response</span>
    }
    <span class="keyword">return</span>
}
</code></pre></div>
<pre class="shell dark">$ go test -benchmem -bench=BenchmarkAlg8 .<br/><span style="color:green;">PASS</span>
ok  	github.com/preferit/cotalk	0.020s
</pre><nav><ul>
<li><a href="#1">1</a></li>
<li><a href="#2">2</a></li>
<li><a href="#3">3</a></li>
<li><a href="#4">4</a></li>
<li><a href="#5">5</a></li>
<li> | </li>
<li><a href="#6">6</a></li>
<li><a href="#7">7</a></li>
<li><a href="#8">8</a></li>
<li> | </li>
<li><a href="#9">9</a></li>
<li><a href="#10">10</a></li>
<li><a href="#11">11</a></li>
<li><a href="#12">12</a></li>
<li><a href="#13">13</a></li>
<li><a href="#14">14</a></li>
<li><a href="#15">15</a></li>
<li><a href="#16">16</a></li>
<li class="current"><a href="#17">17</a></li>
</ul>
</nav>
</div>
</body>
</html>
